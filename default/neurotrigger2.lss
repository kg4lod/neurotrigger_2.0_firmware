
neurotrigger2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001374  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00802000  00001374  00001408  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000116  00802002  00802002  0000140a  2**0
                  ALLOC
  3 .debug_aranges 00000100  00000000  00000000  0000140a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000632  00000000  00000000  0000150a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003fcd  00000000  00000000  00001b3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b23  00000000  00000000  00005b09  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001b8d  00000000  00000000  0000662c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000480  00000000  00000000  000081bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000bff  00000000  00000000  0000863c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000007a1  00000000  00000000  0000923b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 bc 00 	jmp	0x178	; 0x178 <__ctors_end>
       4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
       8:	0c 94 a3 05 	jmp	0xb46	; 0xb46 <__vector_2>
       c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      10:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      14:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      18:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      1c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      20:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      24:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      28:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      2c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      30:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      34:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      38:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      3c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      40:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      44:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      48:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      4c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      50:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      54:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      58:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      5c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      60:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      64:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      68:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      6c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      70:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      74:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      78:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      7c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      80:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      84:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      88:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      8c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      90:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      94:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      98:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      9c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      a0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      a4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      a8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      ac:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      b0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      b4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      b8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      bc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      c0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      c4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      c8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      cc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      d0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      d4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      d8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      dc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      e0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      e4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      e8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      ec:	0c 94 df 08 	jmp	0x11be	; 0x11be <__vector_59>
      f0:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      f4:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      f8:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
      fc:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     100:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     104:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     108:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     10c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     110:	0c 94 16 08 	jmp	0x102c	; 0x102c <__vector_68>
     114:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     118:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     11c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     120:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     124:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     128:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     12c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     130:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     134:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     138:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     13c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     140:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     144:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     148:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     14c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     150:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     154:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     158:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     15c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     160:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     164:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     168:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     16c:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     170:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>
     174:	0c 94 d9 00 	jmp	0x1b2	; 0x1b2 <__bad_interrupt>

00000178 <__ctors_end>:
     178:	11 24       	eor	r1, r1
     17a:	1f be       	out	0x3f, r1	; 63
     17c:	cf ef       	ldi	r28, 0xFF	; 255
     17e:	d7 e2       	ldi	r29, 0x27	; 39
     180:	de bf       	out	0x3e, r29	; 62
     182:	cd bf       	out	0x3d, r28	; 61

00000184 <__do_copy_data>:
     184:	10 e2       	ldi	r17, 0x20	; 32
     186:	a0 e0       	ldi	r26, 0x00	; 0
     188:	b0 e2       	ldi	r27, 0x20	; 32
     18a:	e4 e7       	ldi	r30, 0x74	; 116
     18c:	f3 e1       	ldi	r31, 0x13	; 19
     18e:	02 c0       	rjmp	.+4      	; 0x194 <.do_copy_data_start>

00000190 <.do_copy_data_loop>:
     190:	05 90       	lpm	r0, Z+
     192:	0d 92       	st	X+, r0

00000194 <.do_copy_data_start>:
     194:	a2 30       	cpi	r26, 0x02	; 2
     196:	b1 07       	cpc	r27, r17
     198:	d9 f7       	brne	.-10     	; 0x190 <.do_copy_data_loop>

0000019a <__do_clear_bss>:
     19a:	11 e2       	ldi	r17, 0x21	; 33
     19c:	a2 e0       	ldi	r26, 0x02	; 2
     19e:	b0 e2       	ldi	r27, 0x20	; 32
     1a0:	01 c0       	rjmp	.+2      	; 0x1a4 <.do_clear_bss_start>

000001a2 <.do_clear_bss_loop>:
     1a2:	1d 92       	st	X+, r1

000001a4 <.do_clear_bss_start>:
     1a4:	a8 31       	cpi	r26, 0x18	; 24
     1a6:	b1 07       	cpc	r27, r17
     1a8:	e1 f7       	brne	.-8      	; 0x1a2 <.do_clear_bss_loop>
     1aa:	0e 94 db 00 	call	0x1b6	; 0x1b6 <main>
     1ae:	0c 94 b8 09 	jmp	0x1370	; 0x1370 <_exit>

000001b2 <__bad_interrupt>:
     1b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001b6 <main>:
#include "pwm.h"
#include "uart_buffer.h"

uint8_t STATE_Autolevel = AUTOLEVEL_IDLE;

int main(void){
     1b6:	df 92       	push	r13
     1b8:	ef 92       	push	r14
     1ba:	ff 92       	push	r15
     1bc:	0f 93       	push	r16
     1be:	1f 93       	push	r17
     1c0:	cf 93       	push	r28
     1c2:	df 93       	push	r29
	uint8_t blah;
	uint16_t blah16;
	int8_t updown;

	//[LED's, Button, & Switches]
		init_ui(); //init LED's first so that they are available for debugging
     1c4:	0e 94 43 05 	call	0xa86	; 0xa86 <init_ui>

	//[CPU CLOCK]
		//Boot up and configure oscillator
			OSC.XOSCCTRL = B8(00100010); //enable external 32kHz Xtal using low-power (e.g. low-swing) mode
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	e0 e5       	ldi	r30, 0x50	; 80
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	82 83       	std	Z+2, r24	; 0x02
			OSC.CTRL = B8(00001011); //enable 32M-RC & External Xtal -- also "enable" 2M-RC since its already running b/c we booted from it and can't actually disable it until we switch sources
     1d0:	8b e0       	ldi	r24, 0x0B	; 11
     1d2:	80 93 50 00 	sts	0x0050, r24
		//Wait for stability
			led_on(LED_LEFT);
     1d6:	80 e0       	ldi	r24, 0x00	; 0
     1d8:	0e 94 8b 05 	call	0xb16	; 0xb16 <led_on>
			//This is actually tricky sequencing because we boot from the 2MHz internal RC so previous write to OSC.CTRL was ineffective at shutting down the 2M-RC so OSC.STATUS will still reflect that it is running
			while(OSC.STATUS != B8(00001011)); //stall for external xtal and 32M-RC stability
     1dc:	80 91 51 00 	lds	r24, 0x0051
     1e0:	8b 30       	cpi	r24, 0x0B	; 11
     1e2:	e1 f7       	brne	.-8      	; 0x1dc <main+0x26>
			led_off(LED_LEFT);
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	0e 94 87 05 	call	0xb0e	; 0xb0e <led_off>
		//Configure 
			OSC.DFLLCTRL = B8(00000010); //use external xtal for 32M-RC calibration
     1ea:	82 e0       	ldi	r24, 0x02	; 2
     1ec:	e0 e5       	ldi	r30, 0x50	; 80
     1ee:	f0 e0       	ldi	r31, 0x00	; 0
     1f0:	86 83       	std	Z+6, r24	; 0x06
			DFLLRC32M.CTRL = B8(00000001); //enable Xtal calibration of internal 32MHz RC oscillator
     1f2:	91 e0       	ldi	r25, 0x01	; 1
     1f4:	90 93 60 00 	sts	0x0060, r25
		//Switch system clock over to stable RC oscillator
			//Switch to 32M-RC as system clock source and disable the 2M-RC that we booted from.
			//----REQUIRES CONFIGURATION PROTECTION REGISTER 
			CCP = CCP_IOREG_gc; //disable change protection for IO register
     1f8:	88 ed       	ldi	r24, 0xD8	; 216
     1fa:	84 bf       	out	0x34, r24	; 52
			CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
     1fc:	90 93 40 00 	sts	0x0040, r25
			OSC.CTRL = B8(00001010); //re-execute this write -- this will shutdown the 2M-RC since we are no longer running from it.
     200:	8a e0       	ldi	r24, 0x0A	; 10
     202:	80 93 50 00 	sts	0x0050, r24
		//Now running live at 32MHz		

	//[UARTs]
		init_uart(&uctrl, BAUD_115200);
     206:	80 ea       	ldi	r24, 0xA0	; 160
     208:	9a e0       	ldi	r25, 0x0A	; 10
     20a:	60 e0       	ldi	r22, 0x00	; 0
     20c:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <init_uart>
		init_uart_buffer(&uctrl);
     210:	80 ea       	ldi	r24, 0xA0	; 160
     212:	9a e0       	ldi	r25, 0x0A	; 10
     214:	0e 94 03 09 	call	0x1206	; 0x1206 <init_uart_buffer>
		init_uart(&udata, BAUD_115200);
     218:	80 eb       	ldi	r24, 0xB0	; 176
     21a:	99 e0       	ldi	r25, 0x09	; 9
     21c:	60 e0       	ldi	r22, 0x00	; 0
     21e:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <init_uart>

	//[ADC]
		init_adc();
     222:	0e 94 66 06 	call	0xccc	; 0xccc <init_adc>

	//[DAC]
		//dac0 is background level
		//dac1 is threshold level
		init_dac();
     226:	0e 94 1c 06 	call	0xc38	; 0xc38 <init_dac>

	//[AC]
		init_ac();
     22a:	0e 94 3c 06 	call	0xc78	; 0xc78 <init_ac>

	//[PWM] 
		init_pwm();
     22e:	0e 94 50 07 	call	0xea0	; 0xea0 <init_pwm>

	//[Realtime Loop Timer]
		//Use PortC's T/C0
		TCC0.CTRLA = 0x07; //Start the timer; Div1024 operation = 32M/1024 = 31250
     232:	87 e0       	ldi	r24, 0x07	; 7
     234:	80 93 00 08 	sts	0x0800, r24
		//TCC0.PER = 31; //992uS per timer period
		TCC0.PER = 100;
     238:	84 e6       	ldi	r24, 0x64	; 100
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	e0 e0       	ldi	r30, 0x00	; 0
     23e:	f8 e0       	ldi	r31, 0x08	; 8
     240:	86 a3       	std	Z+38, r24	; 0x26
     242:	97 a3       	std	Z+39, r25	; 0x27

	//[PMIC (Interrupt Controller)]
		PMIC.CTRL = B8(10000111); //enable all three interrupt levels (lowest one with round-robin)
     244:	87 e8       	ldi	r24, 0x87	; 135
     246:	e0 ea       	ldi	r30, 0xA0	; 160
     248:	f0 e0       	ldi	r31, 0x00	; 0
     24a:	82 83       	std	Z+2, r24	; 0x02
		sei(); //ENABLE INTERRUPTS AND GO LIVE!
     24c:	78 94       	sei

	//[RTOS START!]	
		blah = 1;
		blah16 = 0;
		updown = 1;
		led_off(LED_LEFT);
     24e:	80 e0       	ldi	r24, 0x00	; 0
     250:	0e 94 87 05 	call	0xb0e	; 0xb0e <led_off>
		led_off(LED_MID);
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	0e 94 87 05 	call	0xb0e	; 0xb0e <led_off>
     25a:	01 e0       	ldi	r16, 0x01	; 1
     25c:	ff 24       	eor	r15, r15
     25e:	f3 94       	inc	r15
				//Set background level
					dac_out0((adc_avg*5)/8 + 170); //background (x*0.625 = x*5/8)
				STATE_Autolevel = AUTOLEVEL_WAIT;
				break;
			case AUTOLEVEL_WAIT:
				STATE_Autolevel = AUTOLEVEL_WAIT2;
     260:	e3 e0       	ldi	r30, 0x03	; 3
     262:	de 2e       	mov	r13, r30
			case AUTOLEVEL_BACKGROUND:
				//Determine background level
					adc_ch1_stats(1024);
				//Set background level
					dac_out0((adc_avg*5)/8 + 170); //background (x*0.625 = x*5/8)
				STATE_Autolevel = AUTOLEVEL_WAIT;
     264:	72 e0       	ldi	r23, 0x02	; 2
     266:	e7 2e       	mov	r14, r23
			default:		
				break;
			}


			while((TCC0.INTFLAGS & _BV(0)) != 0x01); //Wait for the loop time to expire
     268:	c0 e0       	ldi	r28, 0x00	; 0
     26a:	d8 e0       	ldi	r29, 0x08	; 8
		updown = 1;
		led_off(LED_LEFT);
		led_off(LED_MID);

		while(1){
			led_dim(LED_LEFT, blah);
     26c:	80 e0       	ldi	r24, 0x00	; 0
     26e:	60 2f       	mov	r22, r16
     270:	0e 94 74 05 	call	0xae8	; 0xae8 <led_dim>
			
			blah += updown;			
     274:	0f 0d       	add	r16, r15
			if ((blah == 255) || (blah == 0)) {
     276:	80 2f       	mov	r24, r16
     278:	81 50       	subi	r24, 0x01	; 1
     27a:	8e 3f       	cpi	r24, 0xFE	; 254
     27c:	08 f0       	brcs	.+2      	; 0x280 <main+0xca>
				updown = -1 * updown;
     27e:	f1 94       	neg	r15
			}
			
			blah16++;
			
			service_pwm();
     280:	0e 94 71 07 	call	0xee2	; 0xee2 <service_pwm>
			service_switches();
     284:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <service_switches>
			service_leds();
     288:	0e 94 a2 05 	call	0xb44	; 0xb44 <service_leds>
			service_button();
     28c:	0e 94 c2 05 	call	0xb84	; 0xb84 <service_button>
			if (STATE_Button == BUTTON_PUSHED){
     290:	10 91 09 20 	lds	r17, 0x2009
     294:	11 30       	cpi	r17, 0x01	; 1
     296:	49 f4       	brne	.+18     	; 0x2aa <main+0xf4>
				if (pwm_mode() == false){
     298:	0e 94 5e 08 	call	0x10bc	; 0x10bc <pwm_mode>
     29c:	88 23       	and	r24, r24
     29e:	29 f4       	brne	.+10     	; 0x2aa <main+0xf4>
					STATE_Autolevel = AUTOLEVEL_BACKGROUND;
     2a0:	10 93 02 20 	sts	0x2002, r17
					led_on(LED_MID);
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	0e 94 8b 05 	call	0xb16	; 0xb16 <led_on>

			//PERFORM AUTO-LEVELING!
				//adc is 503uV resolution
				//dac is 806uV resolution
				//ergo ADC -> DAC values must be adjusted by: (x*0.625 = x*5/8)
			switch(STATE_Autolevel){
     2aa:	80 91 02 20 	lds	r24, 0x2002
     2ae:	82 30       	cpi	r24, 0x02	; 2
     2b0:	01 f1       	breq	.+64     	; 0x2f2 <main+0x13c>
     2b2:	83 30       	cpi	r24, 0x03	; 3
     2b4:	09 f1       	breq	.+66     	; 0x2f8 <main+0x142>
     2b6:	81 30       	cpi	r24, 0x01	; 1
     2b8:	09 f0       	breq	.+2      	; 0x2bc <main+0x106>
     2ba:	6b c0       	rjmp	.+214    	; 0x392 <main+0x1dc>
			case AUTOLEVEL_BACKGROUND:
				//Determine background level
					adc_ch1_stats(1024);
     2bc:	80 e0       	ldi	r24, 0x00	; 0
     2be:	94 e0       	ldi	r25, 0x04	; 4
     2c0:	0e 94 f2 06 	call	0xde4	; 0xde4 <adc_ch1_stats>
				//Set background level
					dac_out0((adc_avg*5)/8 + 170); //background (x*0.625 = x*5/8)
     2c4:	20 91 07 20 	lds	r18, 0x2007
     2c8:	30 91 08 20 	lds	r19, 0x2008
     2cc:	c9 01       	movw	r24, r18
     2ce:	88 0f       	add	r24, r24
     2d0:	99 1f       	adc	r25, r25
     2d2:	88 0f       	add	r24, r24
     2d4:	99 1f       	adc	r25, r25
     2d6:	82 0f       	add	r24, r18
     2d8:	93 1f       	adc	r25, r19
     2da:	53 e0       	ldi	r21, 0x03	; 3
     2dc:	96 95       	lsr	r25
     2de:	87 95       	ror	r24
     2e0:	5a 95       	dec	r21
     2e2:	e1 f7       	brne	.-8      	; 0x2dc <main+0x126>
     2e4:	86 55       	subi	r24, 0x56	; 86
     2e6:	9f 4f       	sbci	r25, 0xFF	; 255
     2e8:	0e 94 31 06 	call	0xc62	; 0xc62 <dac_out0>
				STATE_Autolevel = AUTOLEVEL_WAIT;
     2ec:	e0 92 02 20 	sts	0x2002, r14
     2f0:	50 c0       	rjmp	.+160    	; 0x392 <main+0x1dc>
				break;
			case AUTOLEVEL_WAIT:
				STATE_Autolevel = AUTOLEVEL_WAIT2;
     2f2:	d0 92 02 20 	sts	0x2002, r13
     2f6:	4d c0       	rjmp	.+154    	; 0x392 <main+0x1dc>
				break;
			case AUTOLEVEL_WAIT2:
				//Measure resulting amplified level		
					adc_ch0_stats(1024);
     2f8:	80 e0       	ldi	r24, 0x00	; 0
     2fa:	94 e0       	ldi	r25, 0x04	; 4
     2fc:	0e 94 95 06 	call	0xd2a	; 0xd2a <adc_ch0_stats>
				//Set threshold!
					dac_out1((adc_max*5)/8 + 512); //threshold
     300:	20 91 0a 20 	lds	r18, 0x200A
     304:	30 91 0b 20 	lds	r19, 0x200B
     308:	c9 01       	movw	r24, r18
     30a:	88 0f       	add	r24, r24
     30c:	99 1f       	adc	r25, r25
     30e:	88 0f       	add	r24, r24
     310:	99 1f       	adc	r25, r25
     312:	82 0f       	add	r24, r18
     314:	93 1f       	adc	r25, r19
     316:	33 e0       	ldi	r19, 0x03	; 3
     318:	96 95       	lsr	r25
     31a:	87 95       	ror	r24
     31c:	3a 95       	dec	r19
     31e:	e1 f7       	brne	.-8      	; 0x318 <main+0x162>
     320:	80 50       	subi	r24, 0x00	; 0
     322:	9e 4f       	sbci	r25, 0xFE	; 254
     324:	0e 94 36 06 	call	0xc6c	; 0xc6c <dac_out1>
					uart_send_byte(&uctrl, ' ');
     328:	80 ea       	ldi	r24, 0xA0	; 160
     32a:	9a e0       	ldi	r25, 0x0A	; 10
     32c:	60 e2       	ldi	r22, 0x20	; 32
     32e:	0e 94 1a 02 	call	0x434	; 0x434 <uart_send_byte>
					uart_send_byte(&uctrl, '+');
     332:	80 ea       	ldi	r24, 0xA0	; 160
     334:	9a e0       	ldi	r25, 0x0A	; 10
     336:	6b e2       	ldi	r22, 0x2B	; 43
     338:	0e 94 1a 02 	call	0x434	; 0x434 <uart_send_byte>
					uart_send_HEX16(&uctrl, adc_max*5/8);
     33c:	80 91 0a 20 	lds	r24, 0x200A
     340:	90 91 0b 20 	lds	r25, 0x200B
     344:	bc 01       	movw	r22, r24
     346:	66 0f       	add	r22, r22
     348:	77 1f       	adc	r23, r23
     34a:	66 0f       	add	r22, r22
     34c:	77 1f       	adc	r23, r23
     34e:	68 0f       	add	r22, r24
     350:	79 1f       	adc	r23, r25
     352:	83 e0       	ldi	r24, 0x03	; 3
     354:	76 95       	lsr	r23
     356:	67 95       	ror	r22
     358:	8a 95       	dec	r24
     35a:	e1 f7       	brne	.-8      	; 0x354 <main+0x19e>
     35c:	80 ea       	ldi	r24, 0xA0	; 160
     35e:	9a e0       	ldi	r25, 0x0A	; 10
     360:	0e 94 3f 04 	call	0x87e	; 0x87e <uart_send_HEX16>
					uart_send_byte(&uctrl, '.');
     364:	80 ea       	ldi	r24, 0xA0	; 160
     366:	9a e0       	ldi	r25, 0x0A	; 10
     368:	6e e2       	ldi	r22, 0x2E	; 46
     36a:	0e 94 1a 02 	call	0x434	; 0x434 <uart_send_byte>
					uart_send_HEX16(&uctrl, adc_max);
     36e:	60 91 0a 20 	lds	r22, 0x200A
     372:	70 91 0b 20 	lds	r23, 0x200B
     376:	80 ea       	ldi	r24, 0xA0	; 160
     378:	9a e0       	ldi	r25, 0x0A	; 10
     37a:	0e 94 3f 04 	call	0x87e	; 0x87e <uart_send_HEX16>
					uart_send_byte(&uctrl, ' ');
     37e:	80 ea       	ldi	r24, 0xA0	; 160
     380:	9a e0       	ldi	r25, 0x0A	; 10
     382:	60 e2       	ldi	r22, 0x20	; 32
     384:	0e 94 1a 02 	call	0x434	; 0x434 <uart_send_byte>
				//Done!
					led_off(LED_MID);
     388:	81 e0       	ldi	r24, 0x01	; 1
     38a:	0e 94 87 05 	call	0xb0e	; 0xb0e <led_off>
				STATE_Autolevel = AUTOLEVEL_IDLE;
     38e:	10 92 02 20 	sts	0x2002, r1
			default:		
				break;
			}


			while((TCC0.INTFLAGS & _BV(0)) != 0x01); //Wait for the loop time to expire
     392:	80 91 0c 08 	lds	r24, 0x080C
     396:	80 ff       	sbrs	r24, 0
     398:	fc cf       	rjmp	.-8      	; 0x392 <main+0x1dc>
			TCC0.INTFLAGS = 0x01; //Clear the interrupt flag
     39a:	81 e0       	ldi	r24, 0x01	; 1
     39c:	8c 87       	std	Y+12, r24	; 0x0c
     39e:	66 cf       	rjmp	.-308    	; 0x26c <main+0xb6>

000003a0 <init_uart>:
//= INITIALIZATION ROUTINES
//==================================

//Select which uart to initialize from the list of defined constants in the io.h
//Pass in Baud rate from a list of defined constants
void init_uart(USART_t* which, uint8_t baud_rate){
     3a0:	dc 01       	movw	r26, r24
	//Config the PORT
		if (&(*which) == &USARTC0){
     3a2:	88 e0       	ldi	r24, 0x08	; 8
     3a4:	a0 3a       	cpi	r26, 0xA0	; 160
     3a6:	b8 07       	cpc	r27, r24
     3a8:	19 f4       	brne	.+6      	; 0x3b0 <init_uart+0x10>
			PORTC.DIRSET = B8(00001000); //TX pin as output
     3aa:	e0 e4       	ldi	r30, 0x40	; 64
     3ac:	f6 e0       	ldi	r31, 0x06	; 6
     3ae:	1c c0       	rjmp	.+56     	; 0x3e8 <init_uart+0x48>
			PORTC.OUTSET = B8(00001000); //TX initial output value is high
		}
		else if (&(*which) == &USARTC1) {
     3b0:	88 e0       	ldi	r24, 0x08	; 8
     3b2:	a0 3b       	cpi	r26, 0xB0	; 176
     3b4:	b8 07       	cpc	r27, r24
     3b6:	19 f4       	brne	.+6      	; 0x3be <init_uart+0x1e>
			PORTC.DIRSET = B8(10000000); //TX pin as output
     3b8:	e0 e4       	ldi	r30, 0x40	; 64
     3ba:	f6 e0       	ldi	r31, 0x06	; 6
     3bc:	0d c0       	rjmp	.+26     	; 0x3d8 <init_uart+0x38>
			PORTC.OUTSET = B8(10000000); //TX initial output value is high
		}
		else if (&(*which) == &USARTD0) {
     3be:	89 e0       	ldi	r24, 0x09	; 9
     3c0:	a0 3a       	cpi	r26, 0xA0	; 160
     3c2:	b8 07       	cpc	r27, r24
     3c4:	19 f4       	brne	.+6      	; 0x3cc <init_uart+0x2c>
			PORTD.DIRSET = B8(00001000); //TX pin as output
     3c6:	e0 e6       	ldi	r30, 0x60	; 96
     3c8:	f6 e0       	ldi	r31, 0x06	; 6
     3ca:	0e c0       	rjmp	.+28     	; 0x3e8 <init_uart+0x48>
			PORTD.OUTSET = B8(00001000); //TX initial output value is high
		}	
		else if (&(*which) == &USARTD1) {
     3cc:	89 e0       	ldi	r24, 0x09	; 9
     3ce:	a0 3b       	cpi	r26, 0xB0	; 176
     3d0:	b8 07       	cpc	r27, r24
     3d2:	21 f4       	brne	.+8      	; 0x3dc <init_uart+0x3c>
			PORTD.DIRSET = B8(10000000); //TX pin as output
     3d4:	e0 e6       	ldi	r30, 0x60	; 96
     3d6:	f6 e0       	ldi	r31, 0x06	; 6
     3d8:	80 e8       	ldi	r24, 0x80	; 128
     3da:	07 c0       	rjmp	.+14     	; 0x3ea <init_uart+0x4a>
			PORTD.OUTSET = B8(10000000); //TX initial output value is high
		}
		else if (&(*which) == &USARTE0) {
     3dc:	8a e0       	ldi	r24, 0x0A	; 10
     3de:	a0 3a       	cpi	r26, 0xA0	; 160
     3e0:	b8 07       	cpc	r27, r24
     3e2:	29 f4       	brne	.+10     	; 0x3ee <init_uart+0x4e>
			PORTE.DIRSET = B8(00001000); //TX pin as output
     3e4:	e0 e8       	ldi	r30, 0x80	; 128
     3e6:	f6 e0       	ldi	r31, 0x06	; 6
     3e8:	88 e0       	ldi	r24, 0x08	; 8
     3ea:	81 83       	std	Z+1, r24	; 0x01
			PORTE.OUTSET = B8(00001000); //TX initial output value is high
     3ec:	85 83       	std	Z+5, r24	; 0x05
		}
		else {
		}
	//Set baud rate
		switch(baud_rate){
     3ee:	61 30       	cpi	r22, 0x01	; 1
     3f0:	41 f0       	breq	.+16     	; 0x402 <init_uart+0x62>
     3f2:	62 30       	cpi	r22, 0x02	; 2
     3f4:	61 f4       	brne	.+24     	; 0x40e <init_uart+0x6e>
		case BAUD_38400:
			//BSEL = 0xCC5; BSCALE = -6; error = 0.01%
			which->BAUDCTRLB = 0xAC;
     3f6:	8c ea       	ldi	r24, 0xAC	; 172
     3f8:	17 96       	adiw	r26, 0x07	; 7
     3fa:	8c 93       	st	X, r24
     3fc:	17 97       	sbiw	r26, 0x07	; 7
			which->BAUDCTRLA = 0xC5;
     3fe:	85 ec       	ldi	r24, 0xC5	; 197
     400:	0b c0       	rjmp	.+22     	; 0x418 <init_uart+0x78>
			break;
		case BAUD_57600:
			//BSEL = 0x86E; BSCALE = -6; error = 0.01%
			which->BAUDCTRLB = 0xA8;
     402:	88 ea       	ldi	r24, 0xA8	; 168
     404:	17 96       	adiw	r26, 0x07	; 7
     406:	8c 93       	st	X, r24
     408:	17 97       	sbiw	r26, 0x07	; 7
			which->BAUDCTRLA = 0x6E;
     40a:	8e e6       	ldi	r24, 0x6E	; 110
     40c:	05 c0       	rjmp	.+10     	; 0x418 <init_uart+0x78>
			break;
		case BAUD_115200:
		default:
			//BSEL = 0x417; BSCALE = -6; error = 0.01%
			which->BAUDCTRLB = 0xA4;
     40e:	84 ea       	ldi	r24, 0xA4	; 164
     410:	17 96       	adiw	r26, 0x07	; 7
     412:	8c 93       	st	X, r24
     414:	17 97       	sbiw	r26, 0x07	; 7
			which->BAUDCTRLA = 0x17;		
     416:	87 e1       	ldi	r24, 0x17	; 23
     418:	16 96       	adiw	r26, 0x06	; 6
     41a:	8c 93       	st	X, r24
     41c:	16 97       	sbiw	r26, 0x06	; 6
		}
	//Config USART Module
		which->CTRLA = 0x00; //Current driver does not enable any interrupts
     41e:	13 96       	adiw	r26, 0x03	; 3
     420:	1c 92       	st	X, r1
     422:	13 97       	sbiw	r26, 0x03	; 3
		which->CTRLB = B8(00011000); //Enable Rx and TX; Do not use double speed mode
     424:	88 e1       	ldi	r24, 0x18	; 24
     426:	14 96       	adiw	r26, 0x04	; 4
     428:	8c 93       	st	X, r24
     42a:	14 97       	sbiw	r26, 0x04	; 4
		which->CTRLC = B8(00000011); //uart Mode; Use N-8-1 frame configuration
     42c:	83 e0       	ldi	r24, 0x03	; 3
     42e:	15 96       	adiw	r26, 0x05	; 5
     430:	8c 93       	st	X, r24
	//
}
     432:	08 95       	ret

00000434 <uart_send_byte>:
//= DISPLAY (BLOCKING) FUNCTIONS
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
     434:	fc 01       	movw	r30, r24
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     436:	81 81       	ldd	r24, Z+1	; 0x01
     438:	85 ff       	sbrs	r24, 5
     43a:	fd cf       	rjmp	.-6      	; 0x436 <uart_send_byte+0x2>
	which->DATA = dataB;	
     43c:	60 83       	st	Z, r22
}
     43e:	08 95       	ret

00000440 <uart_send_BIN4>:

//Most Significant Bit first
void uart_send_BIN4(USART_t* which, uint8_t lowb){
     440:	fc 01       	movw	r30, r24
	switch(lowb){
     442:	67 30       	cpi	r22, 0x07	; 7
     444:	09 f4       	brne	.+2      	; 0x448 <uart_send_BIN4+0x8>
     446:	b2 c0       	rjmp	.+356    	; 0x5ac <uart_send_BIN4+0x16c>
     448:	68 30       	cpi	r22, 0x08	; 8
     44a:	90 f4       	brcc	.+36     	; 0x470 <uart_send_BIN4+0x30>
     44c:	63 30       	cpi	r22, 0x03	; 3
     44e:	09 f4       	brne	.+2      	; 0x452 <uart_send_BIN4+0x12>
     450:	61 c0       	rjmp	.+194    	; 0x514 <uart_send_BIN4+0xd4>
     452:	64 30       	cpi	r22, 0x04	; 4
     454:	30 f4       	brcc	.+12     	; 0x462 <uart_send_BIN4+0x22>
     456:	61 30       	cpi	r22, 0x01	; 1
     458:	b9 f1       	breq	.+110    	; 0x4c8 <uart_send_BIN4+0x88>
     45a:	62 30       	cpi	r22, 0x02	; 2
     45c:	08 f0       	brcs	.+2      	; 0x460 <uart_send_BIN4+0x20>
     45e:	47 c0       	rjmp	.+142    	; 0x4ee <uart_send_BIN4+0xae>
     460:	20 c0       	rjmp	.+64     	; 0x4a2 <uart_send_BIN4+0x62>
     462:	65 30       	cpi	r22, 0x05	; 5
     464:	09 f4       	brne	.+2      	; 0x468 <uart_send_BIN4+0x28>
     466:	7c c0       	rjmp	.+248    	; 0x560 <uart_send_BIN4+0x120>
     468:	66 30       	cpi	r22, 0x06	; 6
     46a:	08 f0       	brcs	.+2      	; 0x46e <uart_send_BIN4+0x2e>
     46c:	8c c0       	rjmp	.+280    	; 0x586 <uart_send_BIN4+0x146>
     46e:	65 c0       	rjmp	.+202    	; 0x53a <uart_send_BIN4+0xfa>
     470:	6b 30       	cpi	r22, 0x0B	; 11
     472:	09 f4       	brne	.+2      	; 0x476 <uart_send_BIN4+0x36>
     474:	e7 c0       	rjmp	.+462    	; 0x644 <uart_send_BIN4+0x204>
     476:	6c 30       	cpi	r22, 0x0C	; 12
     478:	38 f4       	brcc	.+14     	; 0x488 <uart_send_BIN4+0x48>
     47a:	69 30       	cpi	r22, 0x09	; 9
     47c:	09 f4       	brne	.+2      	; 0x480 <uart_send_BIN4+0x40>
     47e:	bc c0       	rjmp	.+376    	; 0x5f8 <uart_send_BIN4+0x1b8>
     480:	6a 30       	cpi	r22, 0x0A	; 10
     482:	08 f0       	brcs	.+2      	; 0x486 <uart_send_BIN4+0x46>
     484:	cc c0       	rjmp	.+408    	; 0x61e <uart_send_BIN4+0x1de>
     486:	a5 c0       	rjmp	.+330    	; 0x5d2 <uart_send_BIN4+0x192>
     488:	6d 30       	cpi	r22, 0x0D	; 13
     48a:	09 f4       	brne	.+2      	; 0x48e <uart_send_BIN4+0x4e>
     48c:	01 c1       	rjmp	.+514    	; 0x690 <uart_send_BIN4+0x250>
     48e:	6d 30       	cpi	r22, 0x0D	; 13
     490:	08 f4       	brcc	.+2      	; 0x494 <uart_send_BIN4+0x54>
     492:	eb c0       	rjmp	.+470    	; 0x66a <uart_send_BIN4+0x22a>
     494:	6e 30       	cpi	r22, 0x0E	; 14
     496:	09 f4       	brne	.+2      	; 0x49a <uart_send_BIN4+0x5a>
     498:	0f c1       	rjmp	.+542    	; 0x6b8 <uart_send_BIN4+0x278>
     49a:	6f 30       	cpi	r22, 0x0F	; 15
     49c:	09 f0       	breq	.+2      	; 0x4a0 <uart_send_BIN4+0x60>
     49e:	35 c1       	rjmp	.+618    	; 0x70a <uart_send_BIN4+0x2ca>
     4a0:	20 c1       	rjmp	.+576    	; 0x6e2 <uart_send_BIN4+0x2a2>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4a2:	81 81       	ldd	r24, Z+1	; 0x01
     4a4:	85 ff       	sbrs	r24, 5
     4a6:	fd cf       	rjmp	.-6      	; 0x4a2 <uart_send_BIN4+0x62>
	which->DATA = dataB;	
     4a8:	80 e3       	ldi	r24, 0x30	; 48
     4aa:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4ac:	81 81       	ldd	r24, Z+1	; 0x01
     4ae:	85 ff       	sbrs	r24, 5
     4b0:	fd cf       	rjmp	.-6      	; 0x4ac <uart_send_BIN4+0x6c>
	which->DATA = dataB;	
     4b2:	80 e3       	ldi	r24, 0x30	; 48
     4b4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4b6:	81 81       	ldd	r24, Z+1	; 0x01
     4b8:	85 ff       	sbrs	r24, 5
     4ba:	fd cf       	rjmp	.-6      	; 0x4b6 <uart_send_BIN4+0x76>
	which->DATA = dataB;	
     4bc:	80 e3       	ldi	r24, 0x30	; 48
     4be:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4c0:	81 81       	ldd	r24, Z+1	; 0x01
     4c2:	85 ff       	sbrs	r24, 5
     4c4:	fd cf       	rjmp	.-6      	; 0x4c0 <uart_send_BIN4+0x80>
     4c6:	0a c1       	rjmp	.+532    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     4c8:	81 81       	ldd	r24, Z+1	; 0x01
     4ca:	85 ff       	sbrs	r24, 5
     4cc:	fd cf       	rjmp	.-6      	; 0x4c8 <uart_send_BIN4+0x88>
     4ce:	80 e3       	ldi	r24, 0x30	; 48
     4d0:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4d2:	81 81       	ldd	r24, Z+1	; 0x01
     4d4:	85 ff       	sbrs	r24, 5
     4d6:	fd cf       	rjmp	.-6      	; 0x4d2 <uart_send_BIN4+0x92>
	which->DATA = dataB;	
     4d8:	80 e3       	ldi	r24, 0x30	; 48
     4da:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4dc:	81 81       	ldd	r24, Z+1	; 0x01
     4de:	85 ff       	sbrs	r24, 5
     4e0:	fd cf       	rjmp	.-6      	; 0x4dc <uart_send_BIN4+0x9c>
	which->DATA = dataB;	
     4e2:	80 e3       	ldi	r24, 0x30	; 48
     4e4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4e6:	81 81       	ldd	r24, Z+1	; 0x01
     4e8:	85 ff       	sbrs	r24, 5
     4ea:	fd cf       	rjmp	.-6      	; 0x4e6 <uart_send_BIN4+0xa6>
     4ec:	e3 c0       	rjmp	.+454    	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     4ee:	81 81       	ldd	r24, Z+1	; 0x01
     4f0:	85 ff       	sbrs	r24, 5
     4f2:	fd cf       	rjmp	.-6      	; 0x4ee <uart_send_BIN4+0xae>
     4f4:	80 e3       	ldi	r24, 0x30	; 48
     4f6:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     4f8:	81 81       	ldd	r24, Z+1	; 0x01
     4fa:	85 ff       	sbrs	r24, 5
     4fc:	fd cf       	rjmp	.-6      	; 0x4f8 <uart_send_BIN4+0xb8>
	which->DATA = dataB;	
     4fe:	80 e3       	ldi	r24, 0x30	; 48
     500:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     502:	81 81       	ldd	r24, Z+1	; 0x01
     504:	85 ff       	sbrs	r24, 5
     506:	fd cf       	rjmp	.-6      	; 0x502 <uart_send_BIN4+0xc2>
	which->DATA = dataB;	
     508:	81 e3       	ldi	r24, 0x31	; 49
     50a:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     50c:	81 81       	ldd	r24, Z+1	; 0x01
     50e:	85 ff       	sbrs	r24, 5
     510:	fd cf       	rjmp	.-6      	; 0x50c <uart_send_BIN4+0xcc>
     512:	e4 c0       	rjmp	.+456    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     514:	81 81       	ldd	r24, Z+1	; 0x01
     516:	85 ff       	sbrs	r24, 5
     518:	fd cf       	rjmp	.-6      	; 0x514 <uart_send_BIN4+0xd4>
     51a:	80 e3       	ldi	r24, 0x30	; 48
     51c:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     51e:	81 81       	ldd	r24, Z+1	; 0x01
     520:	85 ff       	sbrs	r24, 5
     522:	fd cf       	rjmp	.-6      	; 0x51e <uart_send_BIN4+0xde>
	which->DATA = dataB;	
     524:	80 e3       	ldi	r24, 0x30	; 48
     526:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     528:	81 81       	ldd	r24, Z+1	; 0x01
     52a:	85 ff       	sbrs	r24, 5
     52c:	fd cf       	rjmp	.-6      	; 0x528 <uart_send_BIN4+0xe8>
	which->DATA = dataB;	
     52e:	81 e3       	ldi	r24, 0x31	; 49
     530:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     532:	81 81       	ldd	r24, Z+1	; 0x01
     534:	85 ff       	sbrs	r24, 5
     536:	fd cf       	rjmp	.-6      	; 0x532 <uart_send_BIN4+0xf2>
     538:	bd c0       	rjmp	.+378    	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     53a:	81 81       	ldd	r24, Z+1	; 0x01
     53c:	85 ff       	sbrs	r24, 5
     53e:	fd cf       	rjmp	.-6      	; 0x53a <uart_send_BIN4+0xfa>
     540:	80 e3       	ldi	r24, 0x30	; 48
     542:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     544:	81 81       	ldd	r24, Z+1	; 0x01
     546:	85 ff       	sbrs	r24, 5
     548:	fd cf       	rjmp	.-6      	; 0x544 <uart_send_BIN4+0x104>
	which->DATA = dataB;	
     54a:	81 e3       	ldi	r24, 0x31	; 49
     54c:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     54e:	81 81       	ldd	r24, Z+1	; 0x01
     550:	85 ff       	sbrs	r24, 5
     552:	fd cf       	rjmp	.-6      	; 0x54e <uart_send_BIN4+0x10e>
	which->DATA = dataB;	
     554:	80 e3       	ldi	r24, 0x30	; 48
     556:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     558:	81 81       	ldd	r24, Z+1	; 0x01
     55a:	85 ff       	sbrs	r24, 5
     55c:	fd cf       	rjmp	.-6      	; 0x558 <uart_send_BIN4+0x118>
     55e:	be c0       	rjmp	.+380    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     560:	81 81       	ldd	r24, Z+1	; 0x01
     562:	85 ff       	sbrs	r24, 5
     564:	fd cf       	rjmp	.-6      	; 0x560 <uart_send_BIN4+0x120>
     566:	80 e3       	ldi	r24, 0x30	; 48
     568:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     56a:	81 81       	ldd	r24, Z+1	; 0x01
     56c:	85 ff       	sbrs	r24, 5
     56e:	fd cf       	rjmp	.-6      	; 0x56a <uart_send_BIN4+0x12a>
	which->DATA = dataB;	
     570:	81 e3       	ldi	r24, 0x31	; 49
     572:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     574:	81 81       	ldd	r24, Z+1	; 0x01
     576:	85 ff       	sbrs	r24, 5
     578:	fd cf       	rjmp	.-6      	; 0x574 <uart_send_BIN4+0x134>
	which->DATA = dataB;	
     57a:	80 e3       	ldi	r24, 0x30	; 48
     57c:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     57e:	81 81       	ldd	r24, Z+1	; 0x01
     580:	85 ff       	sbrs	r24, 5
     582:	fd cf       	rjmp	.-6      	; 0x57e <uart_send_BIN4+0x13e>
     584:	97 c0       	rjmp	.+302    	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     586:	81 81       	ldd	r24, Z+1	; 0x01
     588:	85 ff       	sbrs	r24, 5
     58a:	fd cf       	rjmp	.-6      	; 0x586 <uart_send_BIN4+0x146>
     58c:	80 e3       	ldi	r24, 0x30	; 48
     58e:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     590:	81 81       	ldd	r24, Z+1	; 0x01
     592:	85 ff       	sbrs	r24, 5
     594:	fd cf       	rjmp	.-6      	; 0x590 <uart_send_BIN4+0x150>
	which->DATA = dataB;	
     596:	81 e3       	ldi	r24, 0x31	; 49
     598:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     59a:	81 81       	ldd	r24, Z+1	; 0x01
     59c:	85 ff       	sbrs	r24, 5
     59e:	fd cf       	rjmp	.-6      	; 0x59a <uart_send_BIN4+0x15a>
	which->DATA = dataB;	
     5a0:	81 e3       	ldi	r24, 0x31	; 49
     5a2:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5a4:	81 81       	ldd	r24, Z+1	; 0x01
     5a6:	85 ff       	sbrs	r24, 5
     5a8:	fd cf       	rjmp	.-6      	; 0x5a4 <uart_send_BIN4+0x164>
     5aa:	98 c0       	rjmp	.+304    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     5ac:	81 81       	ldd	r24, Z+1	; 0x01
     5ae:	85 ff       	sbrs	r24, 5
     5b0:	fd cf       	rjmp	.-6      	; 0x5ac <uart_send_BIN4+0x16c>
     5b2:	80 e3       	ldi	r24, 0x30	; 48
     5b4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5b6:	81 81       	ldd	r24, Z+1	; 0x01
     5b8:	85 ff       	sbrs	r24, 5
     5ba:	fd cf       	rjmp	.-6      	; 0x5b6 <uart_send_BIN4+0x176>
	which->DATA = dataB;	
     5bc:	81 e3       	ldi	r24, 0x31	; 49
     5be:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5c0:	81 81       	ldd	r24, Z+1	; 0x01
     5c2:	85 ff       	sbrs	r24, 5
     5c4:	fd cf       	rjmp	.-6      	; 0x5c0 <uart_send_BIN4+0x180>
	which->DATA = dataB;	
     5c6:	81 e3       	ldi	r24, 0x31	; 49
     5c8:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5ca:	81 81       	ldd	r24, Z+1	; 0x01
     5cc:	85 ff       	sbrs	r24, 5
     5ce:	fd cf       	rjmp	.-6      	; 0x5ca <uart_send_BIN4+0x18a>
     5d0:	71 c0       	rjmp	.+226    	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     5d2:	81 81       	ldd	r24, Z+1	; 0x01
     5d4:	85 ff       	sbrs	r24, 5
     5d6:	fd cf       	rjmp	.-6      	; 0x5d2 <uart_send_BIN4+0x192>
     5d8:	81 e3       	ldi	r24, 0x31	; 49
     5da:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5dc:	81 81       	ldd	r24, Z+1	; 0x01
     5de:	85 ff       	sbrs	r24, 5
     5e0:	fd cf       	rjmp	.-6      	; 0x5dc <uart_send_BIN4+0x19c>
	which->DATA = dataB;	
     5e2:	80 e3       	ldi	r24, 0x30	; 48
     5e4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5e6:	81 81       	ldd	r24, Z+1	; 0x01
     5e8:	85 ff       	sbrs	r24, 5
     5ea:	fd cf       	rjmp	.-6      	; 0x5e6 <uart_send_BIN4+0x1a6>
	which->DATA = dataB;	
     5ec:	80 e3       	ldi	r24, 0x30	; 48
     5ee:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     5f0:	81 81       	ldd	r24, Z+1	; 0x01
     5f2:	85 ff       	sbrs	r24, 5
     5f4:	fd cf       	rjmp	.-6      	; 0x5f0 <uart_send_BIN4+0x1b0>
     5f6:	72 c0       	rjmp	.+228    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     5f8:	81 81       	ldd	r24, Z+1	; 0x01
     5fa:	85 ff       	sbrs	r24, 5
     5fc:	fd cf       	rjmp	.-6      	; 0x5f8 <uart_send_BIN4+0x1b8>
     5fe:	81 e3       	ldi	r24, 0x31	; 49
     600:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     602:	81 81       	ldd	r24, Z+1	; 0x01
     604:	85 ff       	sbrs	r24, 5
     606:	fd cf       	rjmp	.-6      	; 0x602 <uart_send_BIN4+0x1c2>
	which->DATA = dataB;	
     608:	80 e3       	ldi	r24, 0x30	; 48
     60a:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     60c:	81 81       	ldd	r24, Z+1	; 0x01
     60e:	85 ff       	sbrs	r24, 5
     610:	fd cf       	rjmp	.-6      	; 0x60c <uart_send_BIN4+0x1cc>
	which->DATA = dataB;	
     612:	80 e3       	ldi	r24, 0x30	; 48
     614:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     616:	81 81       	ldd	r24, Z+1	; 0x01
     618:	85 ff       	sbrs	r24, 5
     61a:	fd cf       	rjmp	.-6      	; 0x616 <uart_send_BIN4+0x1d6>
     61c:	4b c0       	rjmp	.+150    	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     61e:	81 81       	ldd	r24, Z+1	; 0x01
     620:	85 ff       	sbrs	r24, 5
     622:	fd cf       	rjmp	.-6      	; 0x61e <uart_send_BIN4+0x1de>
     624:	81 e3       	ldi	r24, 0x31	; 49
     626:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     628:	81 81       	ldd	r24, Z+1	; 0x01
     62a:	85 ff       	sbrs	r24, 5
     62c:	fd cf       	rjmp	.-6      	; 0x628 <uart_send_BIN4+0x1e8>
	which->DATA = dataB;	
     62e:	80 e3       	ldi	r24, 0x30	; 48
     630:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     632:	81 81       	ldd	r24, Z+1	; 0x01
     634:	85 ff       	sbrs	r24, 5
     636:	fd cf       	rjmp	.-6      	; 0x632 <uart_send_BIN4+0x1f2>
	which->DATA = dataB;	
     638:	81 e3       	ldi	r24, 0x31	; 49
     63a:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     63c:	81 81       	ldd	r24, Z+1	; 0x01
     63e:	85 ff       	sbrs	r24, 5
     640:	fd cf       	rjmp	.-6      	; 0x63c <uart_send_BIN4+0x1fc>
     642:	4c c0       	rjmp	.+152    	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     644:	81 81       	ldd	r24, Z+1	; 0x01
     646:	85 ff       	sbrs	r24, 5
     648:	fd cf       	rjmp	.-6      	; 0x644 <uart_send_BIN4+0x204>
     64a:	81 e3       	ldi	r24, 0x31	; 49
     64c:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     64e:	81 81       	ldd	r24, Z+1	; 0x01
     650:	85 ff       	sbrs	r24, 5
     652:	fd cf       	rjmp	.-6      	; 0x64e <uart_send_BIN4+0x20e>
	which->DATA = dataB;	
     654:	80 e3       	ldi	r24, 0x30	; 48
     656:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     658:	81 81       	ldd	r24, Z+1	; 0x01
     65a:	85 ff       	sbrs	r24, 5
     65c:	fd cf       	rjmp	.-6      	; 0x658 <uart_send_BIN4+0x218>
	which->DATA = dataB;	
     65e:	81 e3       	ldi	r24, 0x31	; 49
     660:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     662:	81 81       	ldd	r24, Z+1	; 0x01
     664:	85 ff       	sbrs	r24, 5
     666:	fd cf       	rjmp	.-6      	; 0x662 <uart_send_BIN4+0x222>
     668:	25 c0       	rjmp	.+74     	; 0x6b4 <uart_send_BIN4+0x274>
	which->DATA = dataB;	
     66a:	81 81       	ldd	r24, Z+1	; 0x01
     66c:	85 ff       	sbrs	r24, 5
     66e:	fd cf       	rjmp	.-6      	; 0x66a <uart_send_BIN4+0x22a>
     670:	81 e3       	ldi	r24, 0x31	; 49
     672:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     674:	81 81       	ldd	r24, Z+1	; 0x01
     676:	85 ff       	sbrs	r24, 5
     678:	fd cf       	rjmp	.-6      	; 0x674 <uart_send_BIN4+0x234>
	which->DATA = dataB;	
     67a:	81 e3       	ldi	r24, 0x31	; 49
     67c:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     67e:	81 81       	ldd	r24, Z+1	; 0x01
     680:	85 ff       	sbrs	r24, 5
     682:	fd cf       	rjmp	.-6      	; 0x67e <uart_send_BIN4+0x23e>
	which->DATA = dataB;	
     684:	80 e3       	ldi	r24, 0x30	; 48
     686:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     688:	81 81       	ldd	r24, Z+1	; 0x01
     68a:	85 ff       	sbrs	r24, 5
     68c:	fd cf       	rjmp	.-6      	; 0x688 <uart_send_BIN4+0x248>
     68e:	26 c0       	rjmp	.+76     	; 0x6dc <uart_send_BIN4+0x29c>
	which->DATA = dataB;	
     690:	81 81       	ldd	r24, Z+1	; 0x01
     692:	85 ff       	sbrs	r24, 5
     694:	fd cf       	rjmp	.-6      	; 0x690 <uart_send_BIN4+0x250>
     696:	81 e3       	ldi	r24, 0x31	; 49
     698:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     69a:	81 81       	ldd	r24, Z+1	; 0x01
     69c:	85 ff       	sbrs	r24, 5
     69e:	fd cf       	rjmp	.-6      	; 0x69a <uart_send_BIN4+0x25a>
	which->DATA = dataB;	
     6a0:	81 e3       	ldi	r24, 0x31	; 49
     6a2:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6a4:	81 81       	ldd	r24, Z+1	; 0x01
     6a6:	85 ff       	sbrs	r24, 5
     6a8:	fd cf       	rjmp	.-6      	; 0x6a4 <uart_send_BIN4+0x264>
	which->DATA = dataB;	
     6aa:	80 e3       	ldi	r24, 0x30	; 48
     6ac:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6ae:	81 81       	ldd	r24, Z+1	; 0x01
     6b0:	85 ff       	sbrs	r24, 5
     6b2:	fd cf       	rjmp	.-6      	; 0x6ae <uart_send_BIN4+0x26e>
	which->DATA = dataB;	
     6b4:	81 e3       	ldi	r24, 0x31	; 49
     6b6:	13 c0       	rjmp	.+38     	; 0x6de <uart_send_BIN4+0x29e>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6b8:	81 81       	ldd	r24, Z+1	; 0x01
     6ba:	85 ff       	sbrs	r24, 5
     6bc:	fd cf       	rjmp	.-6      	; 0x6b8 <uart_send_BIN4+0x278>
	which->DATA = dataB;	
     6be:	81 e3       	ldi	r24, 0x31	; 49
     6c0:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6c2:	81 81       	ldd	r24, Z+1	; 0x01
     6c4:	85 ff       	sbrs	r24, 5
     6c6:	fd cf       	rjmp	.-6      	; 0x6c2 <uart_send_BIN4+0x282>
	which->DATA = dataB;	
     6c8:	81 e3       	ldi	r24, 0x31	; 49
     6ca:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6cc:	81 81       	ldd	r24, Z+1	; 0x01
     6ce:	85 ff       	sbrs	r24, 5
     6d0:	fd cf       	rjmp	.-6      	; 0x6cc <uart_send_BIN4+0x28c>
	which->DATA = dataB;	
     6d2:	81 e3       	ldi	r24, 0x31	; 49
     6d4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6d6:	81 81       	ldd	r24, Z+1	; 0x01
     6d8:	85 ff       	sbrs	r24, 5
     6da:	fd cf       	rjmp	.-6      	; 0x6d6 <uart_send_BIN4+0x296>
	which->DATA = dataB;	
     6dc:	80 e3       	ldi	r24, 0x30	; 48
     6de:	80 83       	st	Z, r24
     6e0:	08 95       	ret
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6e2:	81 81       	ldd	r24, Z+1	; 0x01
     6e4:	85 ff       	sbrs	r24, 5
     6e6:	fd cf       	rjmp	.-6      	; 0x6e2 <uart_send_BIN4+0x2a2>
	which->DATA = dataB;	
     6e8:	81 e3       	ldi	r24, 0x31	; 49
     6ea:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6ec:	81 81       	ldd	r24, Z+1	; 0x01
     6ee:	85 ff       	sbrs	r24, 5
     6f0:	fd cf       	rjmp	.-6      	; 0x6ec <uart_send_BIN4+0x2ac>
	which->DATA = dataB;	
     6f2:	81 e3       	ldi	r24, 0x31	; 49
     6f4:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     6f6:	81 81       	ldd	r24, Z+1	; 0x01
     6f8:	85 ff       	sbrs	r24, 5
     6fa:	fd cf       	rjmp	.-6      	; 0x6f6 <uart_send_BIN4+0x2b6>
	which->DATA = dataB;	
     6fc:	81 e3       	ldi	r24, 0x31	; 49
     6fe:	80 83       	st	Z, r24
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     700:	81 81       	ldd	r24, Z+1	; 0x01
     702:	85 ff       	sbrs	r24, 5
     704:	fd cf       	rjmp	.-6      	; 0x700 <uart_send_BIN4+0x2c0>
	which->DATA = dataB;	
     706:	81 e3       	ldi	r24, 0x31	; 49
     708:	80 83       	st	Z, r24
     70a:	08 95       	ret

0000070c <uart_send_BIN8>:
		break;
	}	
}

//Sends out tosend as ASCII text in 'b01101010' format
void uart_send_BIN8(USART_t* which, uint8_t lowb){
     70c:	1f 93       	push	r17
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	ec 01       	movw	r28, r24
     714:	16 2f       	mov	r17, r22
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     716:	89 81       	ldd	r24, Y+1	; 0x01
     718:	85 ff       	sbrs	r24, 5
     71a:	fd cf       	rjmp	.-6      	; 0x716 <uart_send_BIN8+0xa>
	which->DATA = dataB;	
     71c:	82 e6       	ldi	r24, 0x62	; 98
     71e:	88 83       	st	Y, r24
}

//Sends out tosend as ASCII text in 'b01101010' format
void uart_send_BIN8(USART_t* which, uint8_t lowb){
	uart_send_byte(which,'b');
	uart_send_BIN4(which, lowb>>4);
     720:	61 2f       	mov	r22, r17
     722:	62 95       	swap	r22
     724:	6f 70       	andi	r22, 0x0F	; 15
     726:	ce 01       	movw	r24, r28
     728:	0e 94 20 02 	call	0x440	; 0x440 <uart_send_BIN4>
	uart_send_BIN4(which, lowb & 0x0F);
     72c:	1f 70       	andi	r17, 0x0F	; 15
     72e:	ce 01       	movw	r24, r28
     730:	61 2f       	mov	r22, r17
     732:	0e 94 20 02 	call	0x440	; 0x440 <uart_send_BIN4>
}
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	1f 91       	pop	r17
     73c:	08 95       	ret

0000073e <uart_send_HEX4>:
	
void uart_send_HEX4(USART_t* which, uint8_t lowb){
     73e:	fc 01       	movw	r30, r24
	switch(lowb){
     740:	67 30       	cpi	r22, 0x07	; 7
     742:	09 f4       	brne	.+2      	; 0x746 <uart_send_HEX4+0x8>
     744:	4b c0       	rjmp	.+150    	; 0x7dc <uart_send_HEX4+0x9e>
     746:	68 30       	cpi	r22, 0x08	; 8
     748:	70 f4       	brcc	.+28     	; 0x766 <uart_send_HEX4+0x28>
     74a:	63 30       	cpi	r22, 0x03	; 3
     74c:	99 f1       	breq	.+102    	; 0x7b4 <uart_send_HEX4+0x76>
     74e:	64 30       	cpi	r22, 0x04	; 4
     750:	28 f4       	brcc	.+10     	; 0x75c <uart_send_HEX4+0x1e>
     752:	61 30       	cpi	r22, 0x01	; 1
     754:	29 f1       	breq	.+74     	; 0x7a0 <uart_send_HEX4+0x62>
     756:	62 30       	cpi	r22, 0x02	; 2
     758:	40 f5       	brcc	.+80     	; 0x7aa <uart_send_HEX4+0x6c>
     75a:	1d c0       	rjmp	.+58     	; 0x796 <uart_send_HEX4+0x58>
     75c:	65 30       	cpi	r22, 0x05	; 5
     75e:	a1 f1       	breq	.+104    	; 0x7c8 <uart_send_HEX4+0x8a>
     760:	66 30       	cpi	r22, 0x06	; 6
     762:	b8 f5       	brcc	.+110    	; 0x7d2 <uart_send_HEX4+0x94>
     764:	2c c0       	rjmp	.+88     	; 0x7be <uart_send_HEX4+0x80>
     766:	6b 30       	cpi	r22, 0x0B	; 11
     768:	09 f4       	brne	.+2      	; 0x76c <uart_send_HEX4+0x2e>
     76a:	4c c0       	rjmp	.+152    	; 0x804 <uart_send_HEX4+0xc6>
     76c:	6c 30       	cpi	r22, 0x0C	; 12
     76e:	30 f4       	brcc	.+12     	; 0x77c <uart_send_HEX4+0x3e>
     770:	69 30       	cpi	r22, 0x09	; 9
     772:	f1 f1       	breq	.+124    	; 0x7f0 <uart_send_HEX4+0xb2>
     774:	6a 30       	cpi	r22, 0x0A	; 10
     776:	08 f0       	brcs	.+2      	; 0x77a <uart_send_HEX4+0x3c>
     778:	40 c0       	rjmp	.+128    	; 0x7fa <uart_send_HEX4+0xbc>
     77a:	35 c0       	rjmp	.+106    	; 0x7e6 <uart_send_HEX4+0xa8>
     77c:	6d 30       	cpi	r22, 0x0D	; 13
     77e:	09 f4       	brne	.+2      	; 0x782 <uart_send_HEX4+0x44>
     780:	4b c0       	rjmp	.+150    	; 0x818 <uart_send_HEX4+0xda>
     782:	6d 30       	cpi	r22, 0x0D	; 13
     784:	08 f4       	brcc	.+2      	; 0x788 <uart_send_HEX4+0x4a>
     786:	43 c0       	rjmp	.+134    	; 0x80e <uart_send_HEX4+0xd0>
     788:	6e 30       	cpi	r22, 0x0E	; 14
     78a:	09 f4       	brne	.+2      	; 0x78e <uart_send_HEX4+0x50>
     78c:	4a c0       	rjmp	.+148    	; 0x822 <uart_send_HEX4+0xe4>
     78e:	6f 30       	cpi	r22, 0x0F	; 15
     790:	09 f0       	breq	.+2      	; 0x794 <uart_send_HEX4+0x56>
     792:	52 c0       	rjmp	.+164    	; 0x838 <uart_send_HEX4+0xfa>
     794:	4c c0       	rjmp	.+152    	; 0x82e <uart_send_HEX4+0xf0>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     796:	81 81       	ldd	r24, Z+1	; 0x01
     798:	85 ff       	sbrs	r24, 5
     79a:	fd cf       	rjmp	.-6      	; 0x796 <uart_send_HEX4+0x58>
	which->DATA = dataB;	
     79c:	80 e3       	ldi	r24, 0x30	; 48
     79e:	45 c0       	rjmp	.+138    	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7a0:	81 81       	ldd	r24, Z+1	; 0x01
     7a2:	85 ff       	sbrs	r24, 5
     7a4:	fd cf       	rjmp	.-6      	; 0x7a0 <uart_send_HEX4+0x62>
	which->DATA = dataB;	
     7a6:	81 e3       	ldi	r24, 0x31	; 49
     7a8:	40 c0       	rjmp	.+128    	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7aa:	81 81       	ldd	r24, Z+1	; 0x01
     7ac:	85 ff       	sbrs	r24, 5
     7ae:	fd cf       	rjmp	.-6      	; 0x7aa <uart_send_HEX4+0x6c>
	which->DATA = dataB;	
     7b0:	82 e3       	ldi	r24, 0x32	; 50
     7b2:	3b c0       	rjmp	.+118    	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7b4:	81 81       	ldd	r24, Z+1	; 0x01
     7b6:	85 ff       	sbrs	r24, 5
     7b8:	fd cf       	rjmp	.-6      	; 0x7b4 <uart_send_HEX4+0x76>
	which->DATA = dataB;	
     7ba:	83 e3       	ldi	r24, 0x33	; 51
     7bc:	36 c0       	rjmp	.+108    	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7be:	81 81       	ldd	r24, Z+1	; 0x01
     7c0:	85 ff       	sbrs	r24, 5
     7c2:	fd cf       	rjmp	.-6      	; 0x7be <uart_send_HEX4+0x80>
	which->DATA = dataB;	
     7c4:	84 e3       	ldi	r24, 0x34	; 52
     7c6:	31 c0       	rjmp	.+98     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7c8:	81 81       	ldd	r24, Z+1	; 0x01
     7ca:	85 ff       	sbrs	r24, 5
     7cc:	fd cf       	rjmp	.-6      	; 0x7c8 <uart_send_HEX4+0x8a>
	which->DATA = dataB;	
     7ce:	85 e3       	ldi	r24, 0x35	; 53
     7d0:	2c c0       	rjmp	.+88     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7d2:	81 81       	ldd	r24, Z+1	; 0x01
     7d4:	85 ff       	sbrs	r24, 5
     7d6:	fd cf       	rjmp	.-6      	; 0x7d2 <uart_send_HEX4+0x94>
	which->DATA = dataB;	
     7d8:	86 e3       	ldi	r24, 0x36	; 54
     7da:	27 c0       	rjmp	.+78     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7dc:	81 81       	ldd	r24, Z+1	; 0x01
     7de:	85 ff       	sbrs	r24, 5
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <uart_send_HEX4+0x9e>
	which->DATA = dataB;	
     7e2:	87 e3       	ldi	r24, 0x37	; 55
     7e4:	22 c0       	rjmp	.+68     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7e6:	81 81       	ldd	r24, Z+1	; 0x01
     7e8:	85 ff       	sbrs	r24, 5
     7ea:	fd cf       	rjmp	.-6      	; 0x7e6 <uart_send_HEX4+0xa8>
	which->DATA = dataB;	
     7ec:	88 e3       	ldi	r24, 0x38	; 56
     7ee:	1d c0       	rjmp	.+58     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7f0:	81 81       	ldd	r24, Z+1	; 0x01
     7f2:	85 ff       	sbrs	r24, 5
     7f4:	fd cf       	rjmp	.-6      	; 0x7f0 <uart_send_HEX4+0xb2>
	which->DATA = dataB;	
     7f6:	89 e3       	ldi	r24, 0x39	; 57
     7f8:	18 c0       	rjmp	.+48     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     7fa:	81 81       	ldd	r24, Z+1	; 0x01
     7fc:	85 ff       	sbrs	r24, 5
     7fe:	fd cf       	rjmp	.-6      	; 0x7fa <uart_send_HEX4+0xbc>
	which->DATA = dataB;	
     800:	81 e4       	ldi	r24, 0x41	; 65
     802:	13 c0       	rjmp	.+38     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     804:	81 81       	ldd	r24, Z+1	; 0x01
     806:	85 ff       	sbrs	r24, 5
     808:	fd cf       	rjmp	.-6      	; 0x804 <uart_send_HEX4+0xc6>
	which->DATA = dataB;	
     80a:	82 e4       	ldi	r24, 0x42	; 66
     80c:	0e c0       	rjmp	.+28     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     80e:	81 81       	ldd	r24, Z+1	; 0x01
     810:	85 ff       	sbrs	r24, 5
     812:	fd cf       	rjmp	.-6      	; 0x80e <uart_send_HEX4+0xd0>
	which->DATA = dataB;	
     814:	83 e4       	ldi	r24, 0x43	; 67
     816:	09 c0       	rjmp	.+18     	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     818:	81 81       	ldd	r24, Z+1	; 0x01
     81a:	85 ff       	sbrs	r24, 5
     81c:	fd cf       	rjmp	.-6      	; 0x818 <uart_send_HEX4+0xda>
	which->DATA = dataB;	
     81e:	84 e4       	ldi	r24, 0x44	; 68
     820:	04 c0       	rjmp	.+8      	; 0x82a <uart_send_HEX4+0xec>
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     822:	81 81       	ldd	r24, Z+1	; 0x01
     824:	85 ff       	sbrs	r24, 5
     826:	fd cf       	rjmp	.-6      	; 0x822 <uart_send_HEX4+0xe4>
	which->DATA = dataB;	
     828:	85 e4       	ldi	r24, 0x45	; 69
     82a:	80 83       	st	Z, r24
     82c:	08 95       	ret
//==================================


//Sends one byte; Spin-lock until UART is ready to transmit (BE CAREFUL!)
void uart_send_byte( USART_t* which, unsigned char dataB){
	while((which->STATUS & USART_DREIF_bm) == 0x00); //wait until the transmit buffer is ready to receive new data (DREIF flag is 1 when empty)
     82e:	81 81       	ldd	r24, Z+1	; 0x01
     830:	85 ff       	sbrs	r24, 5
     832:	fd cf       	rjmp	.-6      	; 0x82e <uart_send_HEX4+0xf0>
	which->DATA = dataB;	
     834:	86 e4       	ldi	r24, 0x46	; 70
     836:	80 83       	st	Z, r24
     838:	08 95       	ret

0000083a <uart_send_HEX8>:
		uart_send_byte( which, 'F');
		break;
	}	
}

void uart_send_HEX8(USART_t* which, uint8_t lowb){
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	8c 01       	movw	r16, r24
     842:	f6 2e       	mov	r15, r22
	uart_send_HEX4(which, lowb>>4);
     844:	62 95       	swap	r22
     846:	6f 70       	andi	r22, 0x0F	; 15
     848:	0e 94 9f 03 	call	0x73e	; 0x73e <uart_send_HEX4>
	uart_send_HEX4(which, lowb & 0x0F);
     84c:	8f e0       	ldi	r24, 0x0F	; 15
     84e:	f8 22       	and	r15, r24
     850:	c8 01       	movw	r24, r16
     852:	6f 2d       	mov	r22, r15
     854:	0e 94 9f 03 	call	0x73e	; 0x73e <uart_send_HEX4>
}
     858:	1f 91       	pop	r17
     85a:	0f 91       	pop	r16
     85c:	ff 90       	pop	r15
     85e:	08 95       	ret

00000860 <uart_send_HEX16b>:

void uart_send_HEX16b(USART_t* which, uint8_t highb, uint8_t lowb){
     860:	ff 92       	push	r15
     862:	0f 93       	push	r16
     864:	1f 93       	push	r17
     866:	8c 01       	movw	r16, r24
     868:	f4 2e       	mov	r15, r20
	uart_send_HEX8(which, highb);
     86a:	0e 94 1d 04 	call	0x83a	; 0x83a <uart_send_HEX8>
	uart_send_HEX8(which, lowb);
     86e:	c8 01       	movw	r24, r16
     870:	6f 2d       	mov	r22, r15
     872:	0e 94 1d 04 	call	0x83a	; 0x83a <uart_send_HEX8>
}
     876:	1f 91       	pop	r17
     878:	0f 91       	pop	r16
     87a:	ff 90       	pop	r15
     87c:	08 95       	ret

0000087e <uart_send_HEX16>:

void uart_send_HEX16(USART_t* which, uint16_t highb){
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	8c 01       	movw	r16, r24
     886:	f6 2e       	mov	r15, r22
     888:	67 2f       	mov	r22, r23
	uint8_t blah;
	blah = (uint8_t)(highb>>8);
	uart_send_HEX8(which, blah);
     88a:	0e 94 1d 04 	call	0x83a	; 0x83a <uart_send_HEX8>
	blah = (uint8_t)(highb & 0x00FF);
	uart_send_HEX8(which, blah);
     88e:	c8 01       	movw	r24, r16
     890:	6f 2d       	mov	r22, r15
     892:	0e 94 1d 04 	call	0x83a	; 0x83a <uart_send_HEX8>
}
     896:	1f 91       	pop	r17
     898:	0f 91       	pop	r16
     89a:	ff 90       	pop	r15
     89c:	08 95       	ret

0000089e <uart_enq_HEX4>:
	uart_enq_BIN4(lowb & 0x0F);
}
	

void uart_enq_HEX4(uint8_t lowb){
	switch(lowb){
     89e:	87 30       	cpi	r24, 0x07	; 7
     8a0:	81 f1       	breq	.+96     	; 0x902 <uart_enq_HEX4+0x64>
     8a2:	88 30       	cpi	r24, 0x08	; 8
     8a4:	70 f4       	brcc	.+28     	; 0x8c2 <uart_enq_HEX4+0x24>
     8a6:	83 30       	cpi	r24, 0x03	; 3
     8a8:	21 f1       	breq	.+72     	; 0x8f2 <uart_enq_HEX4+0x54>
     8aa:	84 30       	cpi	r24, 0x04	; 4
     8ac:	28 f4       	brcc	.+10     	; 0x8b8 <uart_enq_HEX4+0x1a>
     8ae:	81 30       	cpi	r24, 0x01	; 1
     8b0:	e1 f0       	breq	.+56     	; 0x8ea <uart_enq_HEX4+0x4c>
     8b2:	82 30       	cpi	r24, 0x02	; 2
     8b4:	e0 f4       	brcc	.+56     	; 0x8ee <uart_enq_HEX4+0x50>
     8b6:	17 c0       	rjmp	.+46     	; 0x8e6 <uart_enq_HEX4+0x48>
     8b8:	85 30       	cpi	r24, 0x05	; 5
     8ba:	f9 f0       	breq	.+62     	; 0x8fa <uart_enq_HEX4+0x5c>
     8bc:	86 30       	cpi	r24, 0x06	; 6
     8be:	f8 f4       	brcc	.+62     	; 0x8fe <uart_enq_HEX4+0x60>
     8c0:	1a c0       	rjmp	.+52     	; 0x8f6 <uart_enq_HEX4+0x58>
     8c2:	8b 30       	cpi	r24, 0x0B	; 11
     8c4:	31 f1       	breq	.+76     	; 0x912 <uart_enq_HEX4+0x74>
     8c6:	8c 30       	cpi	r24, 0x0C	; 12
     8c8:	28 f4       	brcc	.+10     	; 0x8d4 <uart_enq_HEX4+0x36>
     8ca:	89 30       	cpi	r24, 0x09	; 9
     8cc:	f1 f0       	breq	.+60     	; 0x90a <uart_enq_HEX4+0x6c>
     8ce:	8a 30       	cpi	r24, 0x0A	; 10
     8d0:	f0 f4       	brcc	.+60     	; 0x90e <uart_enq_HEX4+0x70>
     8d2:	19 c0       	rjmp	.+50     	; 0x906 <uart_enq_HEX4+0x68>
     8d4:	8d 30       	cpi	r24, 0x0D	; 13
     8d6:	09 f1       	breq	.+66     	; 0x91a <uart_enq_HEX4+0x7c>
     8d8:	8d 30       	cpi	r24, 0x0D	; 13
     8da:	e8 f0       	brcs	.+58     	; 0x916 <uart_enq_HEX4+0x78>
     8dc:	8e 30       	cpi	r24, 0x0E	; 14
     8de:	f9 f0       	breq	.+62     	; 0x91e <uart_enq_HEX4+0x80>
     8e0:	8f 30       	cpi	r24, 0x0F	; 15
     8e2:	21 f5       	brne	.+72     	; 0x92c <uart_enq_HEX4+0x8e>
     8e4:	20 c0       	rjmp	.+64     	; 0x926 <uart_enq_HEX4+0x88>
	case(0):
		uart_enqueue( '0');
     8e6:	80 e3       	ldi	r24, 0x30	; 48
     8e8:	1b c0       	rjmp	.+54     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(1):
		uart_enqueue( '1');
     8ea:	81 e3       	ldi	r24, 0x31	; 49
     8ec:	19 c0       	rjmp	.+50     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(2):
		uart_enqueue( '2');
     8ee:	82 e3       	ldi	r24, 0x32	; 50
     8f0:	17 c0       	rjmp	.+46     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(3):
		uart_enqueue( '3');
     8f2:	83 e3       	ldi	r24, 0x33	; 51
     8f4:	15 c0       	rjmp	.+42     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(4):
		uart_enqueue( '4');
     8f6:	84 e3       	ldi	r24, 0x34	; 52
     8f8:	13 c0       	rjmp	.+38     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(5):
		uart_enqueue( '5');
     8fa:	85 e3       	ldi	r24, 0x35	; 53
     8fc:	11 c0       	rjmp	.+34     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(6):
		uart_enqueue( '6');
     8fe:	86 e3       	ldi	r24, 0x36	; 54
     900:	0f c0       	rjmp	.+30     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(7):
		uart_enqueue( '7');
     902:	87 e3       	ldi	r24, 0x37	; 55
     904:	0d c0       	rjmp	.+26     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(8):
		uart_enqueue( '8');
     906:	88 e3       	ldi	r24, 0x38	; 56
     908:	0b c0       	rjmp	.+22     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(9):
		uart_enqueue( '9');
     90a:	89 e3       	ldi	r24, 0x39	; 57
     90c:	09 c0       	rjmp	.+18     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(10):
		uart_enqueue( 'A');
     90e:	81 e4       	ldi	r24, 0x41	; 65
     910:	07 c0       	rjmp	.+14     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(11):
		uart_enqueue( 'B');
     912:	82 e4       	ldi	r24, 0x42	; 66
     914:	05 c0       	rjmp	.+10     	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(12):
		uart_enqueue( 'C');
     916:	83 e4       	ldi	r24, 0x43	; 67
     918:	03 c0       	rjmp	.+6      	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(13):
		uart_enqueue( 'D');
     91a:	84 e4       	ldi	r24, 0x44	; 68
     91c:	01 c0       	rjmp	.+2      	; 0x920 <uart_enq_HEX4+0x82>
		break;
	case(14):
		uart_enqueue( 'E');
     91e:	85 e4       	ldi	r24, 0x45	; 69
     920:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
     924:	08 95       	ret
		break;
	case(15):
		uart_enqueue( 'F');
     926:	86 e4       	ldi	r24, 0x46	; 70
     928:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
     92c:	08 95       	ret

0000092e <uart_enq_HEX8>:
		break;
	}	
}

void uart_enq_HEX8(uint8_t lowb){
     92e:	1f 93       	push	r17
     930:	18 2f       	mov	r17, r24
	uart_enq_HEX4(lowb>>4);
     932:	82 95       	swap	r24
     934:	8f 70       	andi	r24, 0x0F	; 15
     936:	0e 94 4f 04 	call	0x89e	; 0x89e <uart_enq_HEX4>
	uart_enq_HEX4(lowb & 0x0F);
     93a:	81 2f       	mov	r24, r17
     93c:	8f 70       	andi	r24, 0x0F	; 15
     93e:	0e 94 4f 04 	call	0x89e	; 0x89e <uart_enq_HEX4>
}
     942:	1f 91       	pop	r17
     944:	08 95       	ret

00000946 <uart_enq_HEX16>:
void uart_enq_HEX16b(uint8_t highb, uint8_t lowb){
	uart_enq_HEX8(highb);
	uart_enq_HEX8(lowb);
}

void uart_enq_HEX16(uint16_t highb){
     946:	1f 93       	push	r17
     948:	18 2f       	mov	r17, r24
	uint8_t blah;
	blah = (uint8_t)(highb>>8);
	uart_enq_HEX8(blah);
     94a:	89 2f       	mov	r24, r25
     94c:	0e 94 97 04 	call	0x92e	; 0x92e <uart_enq_HEX8>
	blah = (uint8_t)(highb & 0x00FF);
	uart_enq_HEX8(blah);
     950:	81 2f       	mov	r24, r17
     952:	0e 94 97 04 	call	0x92e	; 0x92e <uart_enq_HEX8>
}
     956:	1f 91       	pop	r17
     958:	08 95       	ret

0000095a <uart_enq_HEX16b>:
void uart_enq_HEX8(uint8_t lowb){
	uart_enq_HEX4(lowb>>4);
	uart_enq_HEX4(lowb & 0x0F);
}

void uart_enq_HEX16b(uint8_t highb, uint8_t lowb){
     95a:	1f 93       	push	r17
     95c:	16 2f       	mov	r17, r22
	uart_enq_HEX8(highb);
     95e:	0e 94 97 04 	call	0x92e	; 0x92e <uart_enq_HEX8>
	uart_enq_HEX8(lowb);
     962:	81 2f       	mov	r24, r17
     964:	0e 94 97 04 	call	0x92e	; 0x92e <uart_enq_HEX8>
}
     968:	1f 91       	pop	r17
     96a:	08 95       	ret

0000096c <uart_enq_BIN4>:
//======================================================================


//Most Significant Bit first
void uart_enq_BIN4(uint8_t lowb){
	switch(lowb){
     96c:	87 30       	cpi	r24, 0x07	; 7
     96e:	91 f1       	breq	.+100    	; 0x9d4 <uart_enq_BIN4+0x68>
     970:	88 30       	cpi	r24, 0x08	; 8
     972:	70 f4       	brcc	.+28     	; 0x990 <uart_enq_BIN4+0x24>
     974:	83 30       	cpi	r24, 0x03	; 3
     976:	31 f1       	breq	.+76     	; 0x9c4 <uart_enq_BIN4+0x58>
     978:	84 30       	cpi	r24, 0x04	; 4
     97a:	28 f4       	brcc	.+10     	; 0x986 <uart_enq_BIN4+0x1a>
     97c:	81 30       	cpi	r24, 0x01	; 1
     97e:	f1 f0       	breq	.+60     	; 0x9bc <uart_enq_BIN4+0x50>
     980:	82 30       	cpi	r24, 0x02	; 2
     982:	f0 f4       	brcc	.+60     	; 0x9c0 <uart_enq_BIN4+0x54>
     984:	19 c0       	rjmp	.+50     	; 0x9b8 <uart_enq_BIN4+0x4c>
     986:	85 30       	cpi	r24, 0x05	; 5
     988:	09 f1       	breq	.+66     	; 0x9cc <uart_enq_BIN4+0x60>
     98a:	86 30       	cpi	r24, 0x06	; 6
     98c:	08 f5       	brcc	.+66     	; 0x9d0 <uart_enq_BIN4+0x64>
     98e:	1c c0       	rjmp	.+56     	; 0x9c8 <uart_enq_BIN4+0x5c>
     990:	8b 30       	cpi	r24, 0x0B	; 11
     992:	a1 f1       	breq	.+104    	; 0x9fc <uart_enq_BIN4+0x90>
     994:	8c 30       	cpi	r24, 0x0C	; 12
     996:	28 f4       	brcc	.+10     	; 0x9a2 <uart_enq_BIN4+0x36>
     998:	89 30       	cpi	r24, 0x09	; 9
     99a:	31 f1       	breq	.+76     	; 0x9e8 <uart_enq_BIN4+0x7c>
     99c:	8a 30       	cpi	r24, 0x0A	; 10
     99e:	48 f5       	brcc	.+82     	; 0x9f2 <uart_enq_BIN4+0x86>
     9a0:	1e c0       	rjmp	.+60     	; 0x9de <uart_enq_BIN4+0x72>
     9a2:	8d 30       	cpi	r24, 0x0D	; 13
     9a4:	d9 f1       	breq	.+118    	; 0xa1c <uart_enq_BIN4+0xb0>
     9a6:	8d 30       	cpi	r24, 0x0D	; 13
     9a8:	88 f1       	brcs	.+98     	; 0xa0c <uart_enq_BIN4+0xa0>
     9aa:	8e 30       	cpi	r24, 0x0E	; 14
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <uart_enq_BIN4+0x44>
     9ae:	41 c0       	rjmp	.+130    	; 0xa32 <uart_enq_BIN4+0xc6>
     9b0:	8f 30       	cpi	r24, 0x0F	; 15
     9b2:	09 f0       	breq	.+2      	; 0x9b6 <uart_enq_BIN4+0x4a>
     9b4:	57 c0       	rjmp	.+174    	; 0xa64 <uart_enq_BIN4+0xf8>
     9b6:	4a c0       	rjmp	.+148    	; 0xa4c <uart_enq_BIN4+0xe0>
	case(0):
		uart_enqueue('0');
     9b8:	80 e3       	ldi	r24, 0x30	; 48
     9ba:	12 c0       	rjmp	.+36     	; 0x9e0 <uart_enq_BIN4+0x74>
		uart_enqueue('0');
		uart_enqueue('0');
		uart_enqueue('0');
		break;
	case(1):
		uart_enqueue('0');
     9bc:	80 e3       	ldi	r24, 0x30	; 48
     9be:	15 c0       	rjmp	.+42     	; 0x9ea <uart_enq_BIN4+0x7e>
		uart_enqueue('0');
		uart_enqueue('0');
		uart_enqueue('1');
		break;
	case(2):
		uart_enqueue('0');
     9c0:	80 e3       	ldi	r24, 0x30	; 48
     9c2:	18 c0       	rjmp	.+48     	; 0x9f4 <uart_enq_BIN4+0x88>
		uart_enqueue('0');
		uart_enqueue('1');
		uart_enqueue('0');
		break;
	case(3):
		uart_enqueue('0');
     9c4:	80 e3       	ldi	r24, 0x30	; 48
     9c6:	1b c0       	rjmp	.+54     	; 0x9fe <uart_enq_BIN4+0x92>
		uart_enqueue('0');
		uart_enqueue('1');
		uart_enqueue('1');
		break;
	case(4):
		uart_enqueue('0');
     9c8:	80 e3       	ldi	r24, 0x30	; 48
     9ca:	21 c0       	rjmp	.+66     	; 0xa0e <uart_enq_BIN4+0xa2>
		uart_enqueue('1');
		uart_enqueue('0');
		uart_enqueue('0');
		break;
	case(5):
		uart_enqueue('0');
     9cc:	80 e3       	ldi	r24, 0x30	; 48
     9ce:	27 c0       	rjmp	.+78     	; 0xa1e <uart_enq_BIN4+0xb2>
		uart_enqueue('1');
		uart_enqueue('0');
		uart_enqueue('1');
		break;
	case(6):
		uart_enqueue('0');
     9d0:	80 e3       	ldi	r24, 0x30	; 48
     9d2:	30 c0       	rjmp	.+96     	; 0xa34 <uart_enq_BIN4+0xc8>
		uart_enqueue('1');
		uart_enqueue('1');
		uart_enqueue('0');
		break;
	case(7):
		uart_enqueue('0');
     9d4:	80 e3       	ldi	r24, 0x30	; 48
     9d6:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     9da:	81 e3       	ldi	r24, 0x31	; 49
     9dc:	13 c0       	rjmp	.+38     	; 0xa04 <uart_enq_BIN4+0x98>
		uart_enqueue('1');
		uart_enqueue('1');
		break;
	case(8):
		uart_enqueue('1');
     9de:	81 e3       	ldi	r24, 0x31	; 49
     9e0:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     9e4:	80 e3       	ldi	r24, 0x30	; 48
     9e6:	16 c0       	rjmp	.+44     	; 0xa14 <uart_enq_BIN4+0xa8>
		uart_enqueue('0');
		uart_enqueue('0');
		break;
	case(9):
		uart_enqueue('1');
     9e8:	81 e3       	ldi	r24, 0x31	; 49
     9ea:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     9ee:	80 e3       	ldi	r24, 0x30	; 48
     9f0:	19 c0       	rjmp	.+50     	; 0xa24 <uart_enq_BIN4+0xb8>
		uart_enqueue('0');
		uart_enqueue('1');
		break;
	case(10):
		uart_enqueue('1');
     9f2:	81 e3       	ldi	r24, 0x31	; 49
     9f4:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     9f8:	80 e3       	ldi	r24, 0x30	; 48
     9fa:	1f c0       	rjmp	.+62     	; 0xa3a <uart_enq_BIN4+0xce>
		uart_enqueue('1');
		uart_enqueue('0');
		break;
	case(11):
		uart_enqueue('1');
     9fc:	81 e3       	ldi	r24, 0x31	; 49
     9fe:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     a02:	80 e3       	ldi	r24, 0x30	; 48
     a04:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a08:	81 e3       	ldi	r24, 0x31	; 49
     a0a:	0f c0       	rjmp	.+30     	; 0xa2a <uart_enq_BIN4+0xbe>
		uart_enqueue('1');
		break;
	case(12):
		uart_enqueue('1');
     a0c:	81 e3       	ldi	r24, 0x31	; 49
     a0e:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a12:	81 e3       	ldi	r24, 0x31	; 49
     a14:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     a18:	80 e3       	ldi	r24, 0x30	; 48
     a1a:	12 c0       	rjmp	.+36     	; 0xa40 <uart_enq_BIN4+0xd4>
		uart_enqueue('0');
		break;
	case(13):
		uart_enqueue('1');
     a1c:	81 e3       	ldi	r24, 0x31	; 49
     a1e:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a22:	81 e3       	ldi	r24, 0x31	; 49
     a24:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     a28:	80 e3       	ldi	r24, 0x30	; 48
     a2a:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a2e:	81 e3       	ldi	r24, 0x31	; 49
     a30:	0a c0       	rjmp	.+20     	; 0xa46 <uart_enq_BIN4+0xda>
		break;
	case(14):
		uart_enqueue('1');
     a32:	81 e3       	ldi	r24, 0x31	; 49
     a34:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a38:	81 e3       	ldi	r24, 0x31	; 49
     a3a:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a3e:	81 e3       	ldi	r24, 0x31	; 49
     a40:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('0');
     a44:	80 e3       	ldi	r24, 0x30	; 48
     a46:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
     a4a:	08 95       	ret
		break;
	case(15):
		uart_enqueue('1');
     a4c:	81 e3       	ldi	r24, 0x31	; 49
     a4e:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a52:	81 e3       	ldi	r24, 0x31	; 49
     a54:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a58:	81 e3       	ldi	r24, 0x31	; 49
     a5a:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('1');
     a5e:	81 e3       	ldi	r24, 0x31	; 49
     a60:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
     a64:	08 95       	ret

00000a66 <uart_enq_BIN8>:
		break;
	}	
}

//enqs out toenq as ASCII text in 'b01101010' format
void uart_enq_BIN8(uint8_t lowb){
     a66:	1f 93       	push	r17
     a68:	18 2f       	mov	r17, r24
	uart_enqueue('b');
     a6a:	82 e6       	ldi	r24, 0x62	; 98
     a6c:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
	uart_enq_BIN4(lowb>>4);
     a70:	81 2f       	mov	r24, r17
     a72:	82 95       	swap	r24
     a74:	8f 70       	andi	r24, 0x0F	; 15
     a76:	0e 94 b6 04 	call	0x96c	; 0x96c <uart_enq_BIN4>
	uart_enq_BIN4(lowb & 0x0F);
     a7a:	81 2f       	mov	r24, r17
     a7c:	8f 70       	andi	r24, 0x0F	; 15
     a7e:	0e 94 b6 04 	call	0x96c	; 0x96c <uart_enq_BIN4>
}
     a82:	1f 91       	pop	r17
     a84:	08 95       	ret

00000a86 <init_ui>:

//Handles all UI hardware (buttons, switches, and lights)

void init_ui(){
	//LED's are located at PD0 (Middle) and PD4 (Left)
	PORTD.DIRSET = 0x11; //pins 0 and 4 to output
     a86:	e0 e6       	ldi	r30, 0x60	; 96
     a88:	f6 e0       	ldi	r31, 0x06	; 6
     a8a:	81 e1       	ldi	r24, 0x11	; 17
     a8c:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = 0x11; //pins 0 and 4 to high (off)
     a8e:	85 83       	std	Z+5, r24	; 0x05
	PORTD.PIN0CTRL = B8(01000000); //Invert the pin (needed to achieve correct PWM output polarity)
     a90:	80 e4       	ldi	r24, 0x40	; 64
     a92:	80 8b       	std	Z+16, r24	; 0x10
	PORTD.PIN4CTRL = B8(01000000); //Invert the pin (needed to achieve correct PWM output polarity)
     a94:	84 8b       	std	Z+20, r24	; 0x14
	TCD0.CTRLA = 0x07; //enable; div1024
     a96:	e0 e0       	ldi	r30, 0x00	; 0
     a98:	f9 e0       	ldi	r31, 0x09	; 9
     a9a:	57 e0       	ldi	r21, 0x07	; 7
     a9c:	50 83       	st	Z, r21
	TCD0.CTRLB = 0x13; //Output Channel A enable; Single-slope PWM
     a9e:	43 e1       	ldi	r20, 0x13	; 19
     aa0:	41 83       	std	Z+1, r20	; 0x01
	TCD0.PER = 0x00FF; //Set the top of the counter to basically force 8 bit operation; we do this for speed when calling dimming functions in the future
     aa2:	2f ef       	ldi	r18, 0xFF	; 255
     aa4:	30 e0       	ldi	r19, 0x00	; 0
     aa6:	26 a3       	std	Z+38, r18	; 0x26
     aa8:	37 a3       	std	Z+39, r19	; 0x27
	TCD0.CCA = 0x0080; //Default to off-level brightness
     aaa:	80 e8       	ldi	r24, 0x80	; 128
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	80 a7       	std	Z+40, r24	; 0x28
     ab0:	91 a7       	std	Z+41, r25	; 0x29
	TCD1.CTRLA = 0x07; //enable; div1024
     ab2:	e0 e4       	ldi	r30, 0x40	; 64
     ab4:	f9 e0       	ldi	r31, 0x09	; 9
     ab6:	50 83       	st	Z, r21
	TCD1.CTRLB = 0x13; //Output Channel A enable; Single-slope PWM
     ab8:	41 83       	std	Z+1, r20	; 0x01
	TCD1.PER = 0x00FF; //Set the top of the counter to basically force 8 bit operation; we do this for speed when calling dimming functions in the future
     aba:	26 a3       	std	Z+38, r18	; 0x26
     abc:	37 a3       	std	Z+39, r19	; 0x27
	TCD1.CCA = 0x0010; //Default to off-level brightness
     abe:	80 e1       	ldi	r24, 0x10	; 16
     ac0:	90 e0       	ldi	r25, 0x00	; 0
     ac2:	80 a7       	std	Z+40, r24	; 0x28
     ac4:	91 a7       	std	Z+41, r25	; 0x29

	//Switches need pull-up resistance
	//	Switches: PC5 = SW1; PC4 = SW2; PC3 = SW3
	PORTC.DIRCLR = B8(00111100); //This is the default condition, but just to be safe
     ac6:	e0 e4       	ldi	r30, 0x40	; 64
     ac8:	f6 e0       	ldi	r31, 0x06	; 6
     aca:	8c e3       	ldi	r24, 0x3C	; 60
     acc:	82 83       	std	Z+2, r24	; 0x02
	PORTC.PIN5CTRL = B8(10011000); //Slew rate limiter on; Internal pull-up on; Sense on both input edges
     ace:	88 e9       	ldi	r24, 0x98	; 152
     ad0:	85 8b       	std	Z+21, r24	; 0x15
	PORTC.PIN4CTRL = B8(10011000); //Slew rate limiter on; Internal pull-up on; Sense on both input edges
     ad2:	84 8b       	std	Z+20, r24	; 0x14
	PORTC.PIN3CTRL = B8(10011000); //Slew rate limiter on; Internal pull-up on; Sense on both input edges	
     ad4:	83 8b       	std	Z+19, r24	; 0x13
	//Button requirements
	//	Button Interrupt Controls
	//	Button: PC2 = Button0
	#define RISING_EDGE 	B8(10011001) //Slew rate limiter on; Internal pull-up on; Sense on rising input edges
	#define FALLING_EDGE 	B8(10011010) //Slew rate limiter on; Internal pull-up on; Sense on falling input edges
	PORTC.INT0MASK = B8(00000100); //Enable interrupt0 channel for PC2 
     ad6:	84 e0       	ldi	r24, 0x04	; 4
     ad8:	82 87       	std	Z+10, r24	; 0x0a
	PORTC.INTCTRL = B8(00000011); //interrupt0 channel set to high priority
     ada:	83 e0       	ldi	r24, 0x03	; 3
     adc:	81 87       	std	Z+9, r24	; 0x09
	PORTC.PIN2CTRL = FALLING_EDGE; 
     ade:	8a e9       	ldi	r24, 0x9A	; 154
     ae0:	82 8b       	std	Z+18, r24	; 0x12
	STATE_Button = BUTTON_IDLE;
     ae2:	10 92 09 20 	sts	0x2009, r1
}
     ae6:	08 95       	ret

00000ae8 <led_dim>:
void led_on(uint8_t which){led_dim(which, 0xff);}

void led_off(uint8_t which){led_dim(which, 0x00);}

void led_dim(uint8_t which, uint8_t brightness){
	switch(which){
     ae8:	88 23       	and	r24, r24
     aea:	19 f0       	breq	.+6      	; 0xaf2 <led_dim+0xa>
     aec:	81 30       	cpi	r24, 0x01	; 1
     aee:	71 f4       	brne	.+28     	; 0xb0c <led_dim+0x24>
     af0:	07 c0       	rjmp	.+14     	; 0xb00 <led_dim+0x18>
	case LED_LEFT:
		TCD1.CCABUF = (uint16_t)brightness;		
     af2:	86 2f       	mov	r24, r22
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	e0 e4       	ldi	r30, 0x40	; 64
     af8:	f9 e0       	ldi	r31, 0x09	; 9
     afa:	80 af       	std	Z+56, r24	; 0x38
     afc:	91 af       	std	Z+57, r25	; 0x39
     afe:	08 95       	ret
		break;
	case LED_MID:
		TCD0.CCABUF = (uint16_t)brightness;		
     b00:	86 2f       	mov	r24, r22
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	e0 e0       	ldi	r30, 0x00	; 0
     b06:	f9 e0       	ldi	r31, 0x09	; 9
     b08:	80 af       	std	Z+56, r24	; 0x38
     b0a:	91 af       	std	Z+57, r25	; 0x39
     b0c:	08 95       	ret

00000b0e <led_off>:
//## LEDs
//#############################################################

void led_on(uint8_t which){led_dim(which, 0xff);}

void led_off(uint8_t which){led_dim(which, 0x00);}
     b0e:	60 e0       	ldi	r22, 0x00	; 0
     b10:	0e 94 74 05 	call	0xae8	; 0xae8 <led_dim>
     b14:	08 95       	ret

00000b16 <led_on>:

//#############################################################
//## LEDs
//#############################################################

void led_on(uint8_t which){led_dim(which, 0xff);}
     b16:	6f ef       	ldi	r22, 0xFF	; 255
     b18:	0e 94 74 05 	call	0xae8	; 0xae8 <led_dim>
     b1c:	08 95       	ret

00000b1e <led_toggle>:
		break;
	}
}

void led_toggle(uint8_t which){
	switch(which){
     b1e:	88 23       	and	r24, r24
     b20:	19 f0       	breq	.+6      	; 0xb28 <led_toggle+0xa>
     b22:	81 30       	cpi	r24, 0x01	; 1
     b24:	71 f4       	brne	.+28     	; 0xb42 <led_toggle+0x24>
     b26:	07 c0       	rjmp	.+14     	; 0xb36 <led_toggle+0x18>
	case LED_LEFT:
		TCD1.CCAL = ~TCD1.CCAL;		
     b28:	80 91 68 09 	lds	r24, 0x0968
     b2c:	80 95       	com	r24
     b2e:	e0 e4       	ldi	r30, 0x40	; 64
     b30:	f9 e0       	ldi	r31, 0x09	; 9
     b32:	80 a7       	std	Z+40, r24	; 0x28
     b34:	08 95       	ret
		break;
	case LED_MID:
		TCD0.CCAL = ~TCD0.CCAL;		
     b36:	80 91 28 09 	lds	r24, 0x0928
     b3a:	80 95       	com	r24
     b3c:	e0 e0       	ldi	r30, 0x00	; 0
     b3e:	f9 e0       	ldi	r31, 0x09	; 9
     b40:	80 a7       	std	Z+40, r24	; 0x28
     b42:	08 95       	ret

00000b44 <service_leds>:
	}
}

void service_leds(){

}
     b44:	08 95       	ret

00000b46 <__vector_2>:
//#############################################################
//## BUTTON -- Interrupt driven
//#############################################################

//Caution with programatic use as I do not implement switch debouncing
SIGNAL(PORTC_INT0_vect){
     b46:	1f 92       	push	r1
     b48:	0f 92       	push	r0
     b4a:	0f b6       	in	r0, 0x3f	; 63
     b4c:	0f 92       	push	r0
     b4e:	11 24       	eor	r1, r1
     b50:	8f 93       	push	r24
     b52:	ef 93       	push	r30
     b54:	ff 93       	push	r31
	if (PORTC.PIN2CTRL == FALLING_EDGE){
     b56:	e0 e4       	ldi	r30, 0x40	; 64
     b58:	f6 e0       	ldi	r31, 0x06	; 6
     b5a:	80 91 52 06 	lds	r24, 0x0652
     b5e:	8a 39       	cpi	r24, 0x9A	; 154
     b60:	21 f4       	brne	.+8      	; 0xb6a <__vector_2+0x24>
		//Just detected a falling edge (button has been pressed in)
		PORTC.PIN2CTRL = RISING_EDGE;
     b62:	89 e9       	ldi	r24, 0x99	; 153
     b64:	82 8b       	std	Z+18, r24	; 0x12
		STATE_Button = BUTTON_PUSHED;
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	03 c0       	rjmp	.+6      	; 0xb70 <__vector_2+0x2a>
	}
	else {
		//Just detected a rising edge (button has been released)
		PORTC.PIN2CTRL = FALLING_EDGE;
     b6a:	8a e9       	ldi	r24, 0x9A	; 154
     b6c:	82 8b       	std	Z+18, r24	; 0x12
		STATE_Button = BUTTON_RELEASED;
     b6e:	82 e0       	ldi	r24, 0x02	; 2
     b70:	80 93 09 20 	sts	0x2009, r24
	}
}
     b74:	ff 91       	pop	r31
     b76:	ef 91       	pop	r30
     b78:	8f 91       	pop	r24
     b7a:	0f 90       	pop	r0
     b7c:	0f be       	out	0x3f, r0	; 63
     b7e:	0f 90       	pop	r0
     b80:	1f 90       	pop	r1
     b82:	18 95       	reti

00000b84 <service_button>:
		//Actions when the button is pushed and held down
	}
	else {
		//Actions when the button is not pressed or held
	}
}
     b84:	08 95       	ret

00000b86 <sw_on>:
//## SWITCHESs -- Polling only
//#############################################################

//	Switches: PC5 = SW1; PC4 = SW2; PC3 = SW3
boolean sw_on(uint8_t which){
	switch(which){
     b86:	81 30       	cpi	r24, 0x01	; 1
     b88:	61 f0       	breq	.+24     	; 0xba2 <sw_on+0x1c>
     b8a:	81 30       	cpi	r24, 0x01	; 1
     b8c:	20 f0       	brcs	.+8      	; 0xb96 <sw_on+0x10>
     b8e:	82 30       	cpi	r24, 0x02	; 2
     b90:	79 f0       	breq	.+30     	; 0xbb0 <sw_on+0x2a>
     b92:	80 e0       	ldi	r24, 0x00	; 0
     b94:	08 95       	ret
	case SW1:
		if ((PORTC.IN & _BV(5)) == 0x00){
     b96:	80 91 48 06 	lds	r24, 0x0648
     b9a:	82 95       	swap	r24
     b9c:	86 95       	lsr	r24
     b9e:	87 70       	andi	r24, 0x07	; 7
     ba0:	04 c0       	rjmp	.+8      	; 0xbaa <sw_on+0x24>
			//Switch is open (off)
			return false;
		}
		break;
	case SW2:
		if ((PORTC.IN & _BV(4)) == 0x00){
     ba2:	80 91 48 06 	lds	r24, 0x0648
     ba6:	82 95       	swap	r24
     ba8:	8f 70       	andi	r24, 0x0F	; 15
     baa:	80 95       	com	r24
     bac:	81 70       	andi	r24, 0x01	; 1
     bae:	08 95       	ret
			//Switch is open (off)
			return false;
		}
		break;
	case SW3:
		if ((PORTC.IN & _BV(3)) == 0x00){
     bb0:	80 91 48 06 	lds	r24, 0x0648
     bb4:	86 95       	lsr	r24
     bb6:	86 95       	lsr	r24
     bb8:	86 95       	lsr	r24
     bba:	80 95       	com	r24
     bbc:	81 70       	andi	r24, 0x01	; 1
		}
		break;
	default:
		return false;
	}
}
     bbe:	08 95       	ret

00000bc0 <service_switches>:

void service_switches(){
	static uint8_t mode = 0; //Store prior MODE state

	//[Switch 1] Audio vs. Photodiode Mode -- use pwm.c / pwm_mode() to test condition
	if (sw_on(SW1) == true){
     bc0:	80 e0       	ldi	r24, 0x00	; 0
     bc2:	0e 94 c3 05 	call	0xb86	; 0xb86 <sw_on>
     bc6:	90 91 03 20 	lds	r25, 0x2003
     bca:	81 30       	cpi	r24, 0x01	; 1
     bcc:	41 f4       	brne	.+16     	; 0xbde <service_switches+0x1e>
		if (mode != MODE_AUDIO){
     bce:	95 33       	cpi	r25, 0x35	; 53
     bd0:	69 f0       	breq	.+26     	; 0xbec <service_switches+0x2c>
			//Just changed modes into AUDIO mode!
			mode = MODE_AUDIO; //update state
     bd2:	85 e3       	ldi	r24, 0x35	; 53
     bd4:	80 93 03 20 	sts	0x2003, r24
			pwm_enable(); //turn on AUDIO mode interrupts and configure!
     bd8:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <pwm_enable>
     bdc:	07 c0       	rjmp	.+14     	; 0xbec <service_switches+0x2c>
		}
	}
	else {
		if (mode != MODE_PHOTO){
     bde:	96 33       	cpi	r25, 0x36	; 54
     be0:	29 f0       	breq	.+10     	; 0xbec <service_switches+0x2c>
			//Just changed modes into PHOTO mode!
			mode = MODE_PHOTO; //update state
     be2:	86 e3       	ldi	r24, 0x36	; 54
     be4:	80 93 03 20 	sts	0x2003, r24
			pwm_disable();
     be8:	0e 94 62 08 	call	0x10c4	; 0x10c4 <pwm_disable>
		}
	}
	//[Switch 2] Output polarity
	if (sw_on(SW2) == true){
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	0e 94 c3 05 	call	0xb86	; 0xb86 <sw_on>
     bf2:	81 30       	cpi	r24, 0x01	; 1
     bf4:	31 f4       	brne	.+12     	; 0xc02 <service_switches+0x42>
		if (pwm_mode() == false) ac_polarity(IDLE_HIGH);
     bf6:	0e 94 5e 08 	call	0x10bc	; 0x10bc <pwm_mode>
     bfa:	88 23       	and	r24, r24
     bfc:	49 f4       	brne	.+18     	; 0xc10 <service_switches+0x50>
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	05 c0       	rjmp	.+10     	; 0xc0c <service_switches+0x4c>
	}
	else {
		if (pwm_mode() == false) ac_polarity(IDLE_LOW);
     c02:	0e 94 5e 08 	call	0x10bc	; 0x10bc <pwm_mode>
     c06:	88 23       	and	r24, r24
     c08:	19 f4       	brne	.+6      	; 0xc10 <service_switches+0x50>
     c0a:	82 e0       	ldi	r24, 0x02	; 2
     c0c:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <ac_polarity>
	}
	//[Switch 3] Hysteresis enable
	if (sw_on(SW3) == true){
     c10:	82 e0       	ldi	r24, 0x02	; 2
     c12:	0e 94 c3 05 	call	0xb86	; 0xb86 <sw_on>
     c16:	81 30       	cpi	r24, 0x01	; 1
     c18:	41 f4       	brne	.+16     	; 0xc2a <service_switches+0x6a>
		if (pwm_mode() == false) ac_hysteresis(LARGE);
     c1a:	0e 94 5e 08 	call	0x10bc	; 0x10bc <pwm_mode>
     c1e:	88 23       	and	r24, r24
     c20:	51 f4       	brne	.+20     	; 0xc36 <service_switches+0x76>
     c22:	82 e0       	ldi	r24, 0x02	; 2
     c24:	0e 94 50 06 	call	0xca0	; 0xca0 <ac_hysteresis>
     c28:	08 95       	ret
	}
	else {
		if (pwm_mode() == false) ac_hysteresis(NONE);
     c2a:	0e 94 5e 08 	call	0x10bc	; 0x10bc <pwm_mode>
     c2e:	88 23       	and	r24, r24
     c30:	11 f4       	brne	.+4      	; 0xc36 <service_switches+0x76>
     c32:	0e 94 50 06 	call	0xca0	; 0xca0 <ac_hysteresis>
     c36:	08 95       	ret

00000c38 <init_dac>:
#include "ui.h"

//Handles the DAC for PORTB

void init_dac(){
	DACB.CTRLA = B8(00001101); //enable DAC and both output pins
     c38:	e0 e2       	ldi	r30, 0x20	; 32
     c3a:	f3 e0       	ldi	r31, 0x03	; 3
     c3c:	8d e0       	ldi	r24, 0x0D	; 13
     c3e:	80 83       	st	Z, r24
	DACB.CTRLB = B8(01000000); //enable sample-and-hold to allow for independent output operation
     c40:	80 e4       	ldi	r24, 0x40	; 64
     c42:	81 83       	std	Z+1, r24	; 0x01
	DACB.CTRLC = B8(00001000); //use AVCC as the reference
     c44:	88 e0       	ldi	r24, 0x08	; 8
     c46:	82 83       	std	Z+2, r24	; 0x02
}
     c48:	08 95       	ret

00000c4a <dac_output0>:

void dac_output0(uint8_t config){
	switch(config){
     c4a:	89 32       	cpi	r24, 0x29	; 41
     c4c:	21 f4       	brne	.+8      	; 0xc56 <dac_output0+0xc>
	case DISABLE:
		DACB.CTRLA = DACB.CTRLA & B8(11111011); //NO DAC output to pin PB2
     c4e:	80 91 20 03 	lds	r24, 0x0320
     c52:	8b 7f       	andi	r24, 0xFB	; 251
     c54:	03 c0       	rjmp	.+6      	; 0xc5c <dac_output0+0x12>
		break;
	case ENABLE:
	default:
		DACB.CTRLA = DACB.CTRLA | B8(00000100); //DAC output to pin PB2
     c56:	80 91 20 03 	lds	r24, 0x0320
     c5a:	84 60       	ori	r24, 0x04	; 4
     c5c:	80 93 20 03 	sts	0x0320, r24
     c60:	08 95       	ret

00000c62 <dac_out0>:
//#############################################################
//## DACs
//#############################################################

//DAC's are 12 bit valued -- numbers outside this range will overflow silently
void dac_out0(uint16_t value){DACB.CH0DATA = value;}
     c62:	e0 e2       	ldi	r30, 0x20	; 32
     c64:	f3 e0       	ldi	r31, 0x03	; 3
     c66:	80 8f       	std	Z+24, r24	; 0x18
     c68:	91 8f       	std	Z+25, r25	; 0x19
     c6a:	08 95       	ret

00000c6c <dac_out1>:
void dac_out1(uint16_t value){DACB.CH1DATA = value;}
     c6c:	e0 e2       	ldi	r30, 0x20	; 32
     c6e:	f3 e0       	ldi	r31, 0x03	; 3
     c70:	82 8f       	std	Z+26, r24	; 0x1a
     c72:	93 8f       	std	Z+27, r25	; 0x1b
     c74:	08 95       	ret

00000c76 <service_dac>:

void service_dac(){	
}
     c76:	08 95       	ret

00000c78 <init_ac>:

//Handles the Analog Comparator

void init_ac(){
	//hysterysis options: 0mV, 20mV, 50mV
	ACA.AC0CTRL = B8(00001101); //enable AC0; 50mV hysterysis; no interrupts; high-speed mode
     c78:	e0 e8       	ldi	r30, 0x80	; 128
     c7a:	f3 e0       	ldi	r31, 0x03	; 3
     c7c:	8d e0       	ldi	r24, 0x0D	; 13
     c7e:	80 83       	st	Z, r24
	ACA.AC0MUXCTRL = B8(00000011); //Pos. input = PA0; Neg. Input = PA5; 
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	82 83       	std	Z+2, r24	; 0x02
	case DISABLE:
		ACA.CTRLA = 0x00; //NO AC output to pin PA7;
		break;
	case ENABLE:
	default:
		ACA.CTRLA = 0x01; //AC output to pin PA7;	
     c84:	81 e0       	ldi	r24, 0x01	; 1
     c86:	84 83       	std	Z+4, r24	; 0x04
void init_ac(){
	//hysterysis options: 0mV, 20mV, 50mV
	ACA.AC0CTRL = B8(00001101); //enable AC0; 50mV hysterysis; no interrupts; high-speed mode
	ACA.AC0MUXCTRL = B8(00000011); //Pos. input = PA0; Neg. Input = PA5; 
	ac_output(ENABLE); //AC output to pin PA7;
}
     c88:	08 95       	ret

00000c8a <ac_output>:

void ac_output(uint8_t config){
	switch(config){
     c8a:	89 32       	cpi	r24, 0x29	; 41
     c8c:	21 f4       	brne	.+8      	; 0xc96 <ac_output+0xc>
	case DISABLE:
		ACA.CTRLA = 0x00; //NO AC output to pin PA7;
     c8e:	e0 e8       	ldi	r30, 0x80	; 128
     c90:	f3 e0       	ldi	r31, 0x03	; 3
     c92:	14 82       	std	Z+4, r1	; 0x04
     c94:	08 95       	ret
		break;
	case ENABLE:
	default:
		ACA.CTRLA = 0x01; //AC output to pin PA7;	
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	e0 e8       	ldi	r30, 0x80	; 128
     c9a:	f3 e0       	ldi	r31, 0x03	; 3
     c9c:	84 83       	std	Z+4, r24	; 0x04
     c9e:	08 95       	ret

00000ca0 <ac_hysteresis>:
//#############################################################
//## ACs
//#############################################################

void ac_hysteresis(uint8_t amount){
	switch(amount){
     ca0:	81 30       	cpi	r24, 0x01	; 1
     ca2:	21 f0       	breq	.+8      	; 0xcac <ac_hysteresis+0xc>
     ca4:	82 30       	cpi	r24, 0x02	; 2
     ca6:	21 f4       	brne	.+8      	; 0xcb0 <ac_hysteresis+0x10>
	case LARGE:
		ACA.AC0CTRL = B8(00001101); //enable AC0; 50mV hysterysis; no interrupts; high-speed mode
     ca8:	8d e0       	ldi	r24, 0x0D	; 13
     caa:	03 c0       	rjmp	.+6      	; 0xcb2 <ac_hysteresis+0x12>
		break;
	case SMALL:
		ACA.AC0CTRL = B8(00001011); //enable AC0; 20mV hysterysis; no interrupts; high-speed mode
     cac:	8b e0       	ldi	r24, 0x0B	; 11
     cae:	01 c0       	rjmp	.+2      	; 0xcb2 <ac_hysteresis+0x12>
		break;
	case NONE:
	default:
		ACA.AC0CTRL = B8(00001001); //enable AC0; no hysterysis; no interrupts; high-speed mode		
     cb0:	89 e0       	ldi	r24, 0x09	; 9
     cb2:	80 93 80 03 	sts	0x0380, r24
     cb6:	08 95       	ret

00000cb8 <ac_polarity>:

//Sets output polarity (e.g. active high or active low output)
void ac_polarity(uint8_t polarity){
	//reverse the comparator inputs to reverse the output polarity
	//pin I/O functions are overridden by the AC unit so I/O inversion is ineffective
	if (polarity == IDLE_HIGH){
     cb8:	81 30       	cpi	r24, 0x01	; 1
     cba:	11 f4       	brne	.+4      	; 0xcc0 <ac_polarity+0x8>
		ACA.AC0MUXCTRL = B8(00101000); //Pos. input = PA5; Neg. Input = PA0; 
     cbc:	88 e2       	ldi	r24, 0x28	; 40
     cbe:	01 c0       	rjmp	.+2      	; 0xcc2 <ac_polarity+0xa>
	}
	else {
		ACA.AC0MUXCTRL = B8(00000011); //Pos. input = PA0; Neg. Input = PA5; 
     cc0:	83 e0       	ldi	r24, 0x03	; 3
     cc2:	e0 e8       	ldi	r30, 0x80	; 128
     cc4:	f3 e0       	ldi	r31, 0x03	; 3
     cc6:	82 83       	std	Z+2, r24	; 0x02
     cc8:	08 95       	ret

00000cca <service_ac>:
	}
}

void service_ac(){	
}
     cca:	08 95       	ret

00000ccc <init_adc>:
#include "adc.h"

//Handles the ADC

void init_adc(){
	ADCA.REFCTRL = B8(00010000); //Use AVCC/1.6 = 2.063V as reference (highest allowed)
     ccc:	e0 e0       	ldi	r30, 0x00	; 0
     cce:	f2 e0       	ldi	r31, 0x02	; 2
     cd0:	90 e1       	ldi	r25, 0x10	; 16
     cd2:	92 83       	std	Z+2, r25	; 0x02
	ADCA.CTRLB = B8(00000000); //12bit-right adjusted; One-shot conversion
     cd4:	11 82       	std	Z+1, r1	; 0x01
	ADCA.CTRLA = B8(00000001); //Enable ADC;
     cd6:	81 e0       	ldi	r24, 0x01	; 1
     cd8:	80 83       	st	Z, r24
	ADCA.CH0.MUXCTRL = B8(00010000); //CH0 converts from PA2
     cda:	91 a3       	std	Z+33, r25	; 0x21
	ADCA.CH1.MUXCTRL = B8(00011000); //CH1 converts from PA3
     cdc:	88 e1       	ldi	r24, 0x18	; 24
     cde:	81 a7       	std	Z+41, r24	; 0x29
}
     ce0:	08 95       	ret

00000ce2 <adc_ch0>:
//#############################################################

//Performs a single 12-bit conversion on ADC CH0
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch0(){
	ADCA.CH0.CTRL = B8(10000001); //Single ended input mode; No gain
     ce2:	81 e8       	ldi	r24, 0x81	; 129
     ce4:	e0 e0       	ldi	r30, 0x00	; 0
     ce6:	f2 e0       	ldi	r31, 0x02	; 2
     ce8:	80 a3       	std	Z+32, r24	; 0x20
	while(ADCA.CH0.INTFLAGS == 0x00); //wait for conversion to complete
     cea:	80 91 23 02 	lds	r24, 0x0223
     cee:	88 23       	and	r24, r24
     cf0:	e1 f3       	breq	.-8      	; 0xcea <adc_ch0+0x8>
	ADCA.CH0.INTFLAGS = 0x01; //clear the conversion complete flag
     cf2:	81 e0       	ldi	r24, 0x01	; 1
     cf4:	e0 e0       	ldi	r30, 0x00	; 0
     cf6:	f2 e0       	ldi	r31, 0x02	; 2
     cf8:	83 a3       	std	Z+35, r24	; 0x23
	return ADCA.CH0.RES;
     cfa:	20 91 24 02 	lds	r18, 0x0224
     cfe:	30 91 25 02 	lds	r19, 0x0225
}
     d02:	c9 01       	movw	r24, r18
     d04:	08 95       	ret

00000d06 <adc_ch1>:

//Performs a single 12-bit conversion on ADC CH1
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch1(){
	ADCA.CH1.CTRL = B8(10000001); //Single ended input mode; No gain
     d06:	81 e8       	ldi	r24, 0x81	; 129
     d08:	e0 e0       	ldi	r30, 0x00	; 0
     d0a:	f2 e0       	ldi	r31, 0x02	; 2
     d0c:	80 a7       	std	Z+40, r24	; 0x28
	while(ADCA.CH1.INTFLAGS == 0x00); //wait for conversion to complete
     d0e:	80 91 2b 02 	lds	r24, 0x022B
     d12:	88 23       	and	r24, r24
     d14:	e1 f3       	breq	.-8      	; 0xd0e <adc_ch1+0x8>
	ADCA.CH1.INTFLAGS = 0x01; //clear the conversion complete flag
     d16:	81 e0       	ldi	r24, 0x01	; 1
     d18:	e0 e0       	ldi	r30, 0x00	; 0
     d1a:	f2 e0       	ldi	r31, 0x02	; 2
     d1c:	83 a7       	std	Z+43, r24	; 0x2b
	return ADCA.CH1.RES;
     d1e:	20 91 2c 02 	lds	r18, 0x022C
     d22:	30 91 2d 02 	lds	r19, 0x022D
}
     d26:	c9 01       	movw	r24, r18
     d28:	08 95       	ret

00000d2a <adc_ch0_stats>:

//Average num_to_avg samples and return the result
//Pass in only power-of-2 integers; Max is 2^20;
//BLOCKS UNTIL ALL CONVERSIONS COMPLETE! USE WITH CAUTION!
//Updates the global adc_stats variables (adc_avg, adc_max, etc)
void adc_ch0_stats(uint16_t num_to_avg){
     d2a:	af 92       	push	r10
     d2c:	bf 92       	push	r11
     d2e:	cf 92       	push	r12
     d30:	df 92       	push	r13
     d32:	ef 92       	push	r14
     d34:	ff 92       	push	r15
     d36:	0f 93       	push	r16
     d38:	1f 93       	push	r17
     d3a:	cf 93       	push	r28
     d3c:	df 93       	push	r29
     d3e:	ac 01       	movw	r20, r24
     d40:	ee 24       	eor	r14, r14
     d42:	ff 24       	eor	r15, r15
     d44:	87 01       	movw	r16, r14
     d46:	20 e0       	ldi	r18, 0x00	; 0
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	ef ef       	ldi	r30, 0xFF	; 255
     d4c:	ff ef       	ldi	r31, 0xFF	; 255
     d4e:	60 e0       	ldi	r22, 0x00	; 0
     d50:	70 e0       	ldi	r23, 0x00	; 0
//#############################################################

//Performs a single 12-bit conversion on ADC CH0
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch0(){
	ADCA.CH0.CTRL = B8(10000001); //Single ended input mode; No gain
     d52:	c1 2c       	mov	r12, r1
     d54:	92 e0       	ldi	r25, 0x02	; 2
     d56:	d9 2e       	mov	r13, r25
     d58:	81 e8       	ldi	r24, 0x81	; 129
     d5a:	a8 2e       	mov	r10, r24
	while(ADCA.CH0.INTFLAGS == 0x00); //wait for conversion to complete
     d5c:	c0 e0       	ldi	r28, 0x00	; 0
     d5e:	d2 e0       	ldi	r29, 0x02	; 2
	ADCA.CH0.INTFLAGS = 0x01; //clear the conversion complete flag
     d60:	bb 24       	eor	r11, r11
     d62:	b3 94       	inc	r11
     d64:	1c c0       	rjmp	.+56     	; 0xd9e <adc_ch0_stats+0x74>
//#############################################################

//Performs a single 12-bit conversion on ADC CH0
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch0(){
	ADCA.CH0.CTRL = B8(10000001); //Single ended input mode; No gain
     d66:	d6 01       	movw	r26, r12
     d68:	90 96       	adiw	r26, 0x20	; 32
     d6a:	ac 92       	st	X, r10
	while(ADCA.CH0.INTFLAGS == 0x00); //wait for conversion to complete
     d6c:	80 91 23 02 	lds	r24, 0x0223
     d70:	88 23       	and	r24, r24
     d72:	e1 f3       	breq	.-8      	; 0xd6c <adc_ch0_stats+0x42>
	ADCA.CH0.INTFLAGS = 0x01; //clear the conversion complete flag
     d74:	bb a2       	std	Y+35, r11	; 0x23
	return ADCA.CH0.RES;
     d76:	80 91 24 02 	lds	r24, 0x0224
     d7a:	90 91 25 02 	lds	r25, 0x0225
     d7e:	8e 17       	cp	r24, r30
     d80:	9f 07       	cpc	r25, r31
     d82:	08 f4       	brcc	.+2      	; 0xd86 <adc_ch0_stats+0x5c>
     d84:	fc 01       	movw	r30, r24
     d86:	68 17       	cp	r22, r24
     d88:	79 07       	cpc	r23, r25
     d8a:	08 f4       	brcc	.+2      	; 0xd8e <adc_ch0_stats+0x64>
     d8c:	bc 01       	movw	r22, r24
	uint16_t i = 0;
	adc_max = 0;
	adc_min = 0xFFFF;
	while(i < num_to_avg){
		intermediate = adc_ch0();
		sum += intermediate; //for averaging
     d8e:	a0 e0       	ldi	r26, 0x00	; 0
     d90:	b0 e0       	ldi	r27, 0x00	; 0
     d92:	e8 0e       	add	r14, r24
     d94:	f9 1e       	adc	r15, r25
     d96:	0a 1f       	adc	r16, r26
     d98:	1b 1f       	adc	r17, r27
		if (intermediate < adc_min) adc_min = intermediate; //check min
		if (intermediate > adc_max) adc_max = intermediate; //check max
		i++;
     d9a:	2f 5f       	subi	r18, 0xFF	; 255
     d9c:	3f 4f       	sbci	r19, 0xFF	; 255
	uint16_t intermediate;
	uint32_t sum = 0;
	uint16_t i = 0;
	adc_max = 0;
	adc_min = 0xFFFF;
	while(i < num_to_avg){
     d9e:	24 17       	cp	r18, r20
     da0:	35 07       	cpc	r19, r21
     da2:	08 f3       	brcs	.-62     	; 0xd66 <adc_ch0_stats+0x3c>
     da4:	e0 93 0c 20 	sts	0x200C, r30
     da8:	f0 93 0d 20 	sts	0x200D, r31
     dac:	60 93 0a 20 	sts	0x200A, r22
     db0:	70 93 0b 20 	sts	0x200B, r23
		sum += intermediate; //for averaging
		if (intermediate < adc_min) adc_min = intermediate; //check min
		if (intermediate > adc_max) adc_max = intermediate; //check max
		i++;
	}
	adc_count = num_to_avg;
     db4:	40 93 06 20 	sts	0x2006, r20
	adc_avg = sum / num_to_avg;
     db8:	9a 01       	movw	r18, r20
     dba:	40 e0       	ldi	r20, 0x00	; 0
     dbc:	50 e0       	ldi	r21, 0x00	; 0
     dbe:	c8 01       	movw	r24, r16
     dc0:	b7 01       	movw	r22, r14
     dc2:	0e 94 96 09 	call	0x132c	; 0x132c <__udivmodsi4>
     dc6:	20 93 07 20 	sts	0x2007, r18
     dca:	30 93 08 20 	sts	0x2008, r19
}
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	1f 91       	pop	r17
     dd4:	0f 91       	pop	r16
     dd6:	ff 90       	pop	r15
     dd8:	ef 90       	pop	r14
     dda:	df 90       	pop	r13
     ddc:	cf 90       	pop	r12
     dde:	bf 90       	pop	r11
     de0:	af 90       	pop	r10
     de2:	08 95       	ret

00000de4 <adc_ch1_stats>:

//Average num_to_avg samples and return the result
//Pass in only power-of-2 integers; Max is 2^20?;
//BLOCKS UNTIL ALL CONVERSIONS COMPLETE! USE WITH CAUTION!
//Updates the global adc_stats variables (adc_avg, adc_max, etc)
void adc_ch1_stats(uint16_t num_to_avg){
     de4:	af 92       	push	r10
     de6:	bf 92       	push	r11
     de8:	cf 92       	push	r12
     dea:	df 92       	push	r13
     dec:	ef 92       	push	r14
     dee:	ff 92       	push	r15
     df0:	0f 93       	push	r16
     df2:	1f 93       	push	r17
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	ac 01       	movw	r20, r24
     dfa:	ee 24       	eor	r14, r14
     dfc:	ff 24       	eor	r15, r15
     dfe:	87 01       	movw	r16, r14
     e00:	20 e0       	ldi	r18, 0x00	; 0
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	ef ef       	ldi	r30, 0xFF	; 255
     e06:	ff ef       	ldi	r31, 0xFF	; 255
     e08:	60 e0       	ldi	r22, 0x00	; 0
     e0a:	70 e0       	ldi	r23, 0x00	; 0
}

//Performs a single 12-bit conversion on ADC CH1
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch1(){
	ADCA.CH1.CTRL = B8(10000001); //Single ended input mode; No gain
     e0c:	c1 2c       	mov	r12, r1
     e0e:	b2 e0       	ldi	r27, 0x02	; 2
     e10:	db 2e       	mov	r13, r27
     e12:	a1 e8       	ldi	r26, 0x81	; 129
     e14:	aa 2e       	mov	r10, r26
	while(ADCA.CH1.INTFLAGS == 0x00); //wait for conversion to complete
     e16:	c0 e0       	ldi	r28, 0x00	; 0
     e18:	d2 e0       	ldi	r29, 0x02	; 2
	ADCA.CH1.INTFLAGS = 0x01; //clear the conversion complete flag
     e1a:	bb 24       	eor	r11, r11
     e1c:	b3 94       	inc	r11
     e1e:	1c c0       	rjmp	.+56     	; 0xe58 <adc_ch1_stats+0x74>
}

//Performs a single 12-bit conversion on ADC CH1
//BLOCKS UNTIL CONVERSION COMPLETE!
uint16_t adc_ch1(){
	ADCA.CH1.CTRL = B8(10000001); //Single ended input mode; No gain
     e20:	d6 01       	movw	r26, r12
     e22:	98 96       	adiw	r26, 0x28	; 40
     e24:	ac 92       	st	X, r10
	while(ADCA.CH1.INTFLAGS == 0x00); //wait for conversion to complete
     e26:	80 91 2b 02 	lds	r24, 0x022B
     e2a:	88 23       	and	r24, r24
     e2c:	e1 f3       	breq	.-8      	; 0xe26 <adc_ch1_stats+0x42>
	ADCA.CH1.INTFLAGS = 0x01; //clear the conversion complete flag
     e2e:	bb a6       	std	Y+43, r11	; 0x2b
	return ADCA.CH1.RES;
     e30:	80 91 2c 02 	lds	r24, 0x022C
     e34:	90 91 2d 02 	lds	r25, 0x022D
     e38:	8e 17       	cp	r24, r30
     e3a:	9f 07       	cpc	r25, r31
     e3c:	08 f4       	brcc	.+2      	; 0xe40 <adc_ch1_stats+0x5c>
     e3e:	fc 01       	movw	r30, r24
     e40:	68 17       	cp	r22, r24
     e42:	79 07       	cpc	r23, r25
     e44:	08 f4       	brcc	.+2      	; 0xe48 <adc_ch1_stats+0x64>
     e46:	bc 01       	movw	r22, r24
	uint16_t i = 0;
	adc_max = 0;
	adc_min = 0xFFFF;
	while(i < num_to_avg){
		intermediate = adc_ch1();
		sum += intermediate; //for averaging
     e48:	a0 e0       	ldi	r26, 0x00	; 0
     e4a:	b0 e0       	ldi	r27, 0x00	; 0
     e4c:	e8 0e       	add	r14, r24
     e4e:	f9 1e       	adc	r15, r25
     e50:	0a 1f       	adc	r16, r26
     e52:	1b 1f       	adc	r17, r27
		if (intermediate < adc_min) adc_min = intermediate; //check min
		if (intermediate > adc_max) adc_max = intermediate; //check max
		i++;
     e54:	2f 5f       	subi	r18, 0xFF	; 255
     e56:	3f 4f       	sbci	r19, 0xFF	; 255
	uint16_t intermediate;
	uint32_t sum = 0;
	uint16_t i = 0;
	adc_max = 0;
	adc_min = 0xFFFF;
	while(i < num_to_avg){
     e58:	24 17       	cp	r18, r20
     e5a:	35 07       	cpc	r19, r21
     e5c:	08 f3       	brcs	.-62     	; 0xe20 <adc_ch1_stats+0x3c>
     e5e:	e0 93 0c 20 	sts	0x200C, r30
     e62:	f0 93 0d 20 	sts	0x200D, r31
     e66:	60 93 0a 20 	sts	0x200A, r22
     e6a:	70 93 0b 20 	sts	0x200B, r23
		sum += intermediate; //for averaging
		if (intermediate < adc_min) adc_min = intermediate; //check min
		if (intermediate > adc_max) adc_max = intermediate; //check max
		i++;
	}
	adc_count = num_to_avg;
     e6e:	40 93 06 20 	sts	0x2006, r20
	adc_avg = sum / num_to_avg;
     e72:	9a 01       	movw	r18, r20
     e74:	40 e0       	ldi	r20, 0x00	; 0
     e76:	50 e0       	ldi	r21, 0x00	; 0
     e78:	c8 01       	movw	r24, r16
     e7a:	b7 01       	movw	r22, r14
     e7c:	0e 94 96 09 	call	0x132c	; 0x132c <__udivmodsi4>
     e80:	20 93 07 20 	sts	0x2007, r18
     e84:	30 93 08 20 	sts	0x2008, r19
}
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	1f 91       	pop	r17
     e8e:	0f 91       	pop	r16
     e90:	ff 90       	pop	r15
     e92:	ef 90       	pop	r14
     e94:	df 90       	pop	r13
     e96:	cf 90       	pop	r12
     e98:	bf 90       	pop	r11
     e9a:	af 90       	pop	r10
     e9c:	08 95       	ret

00000e9e <service_adc>:

void service_adc(){	
}
     e9e:	08 95       	ret

00000ea0 <init_pwm>:
uint8_t STATE_Pwm = PWM_OUTPUT_LOW;

//Initialize the PWM module
void init_pwm(){
	//no init needed. We initialize when the mode is activated.
}
     ea0:	08 95       	ret

00000ea2 <pwm_timer_reset>:
//#############################################################
//## TIMER CAPTURE FUNCTIONS
//#############################################################
void pwm_timer_reset(void){
	//Reset the timer effective immediately!
	TCE0.CNTL = 0x00;
     ea2:	e0 e0       	ldi	r30, 0x00	; 0
     ea4:	fa e0       	ldi	r31, 0x0A	; 10
     ea6:	10 a2       	std	Z+32, r1	; 0x20
	TCE0.CNTH = 0x00;	
     ea8:	11 a2       	std	Z+33, r1	; 0x21
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
     eaa:	8f ef       	ldi	r24, 0xFF	; 255
     eac:	84 87       	std	Z+12, r24	; 0x0c
}
     eae:	08 95       	ret

00000eb0 <between>:

boolean between(uint16_t var, uint16_t low, uint16_t high){
	if ((var > low) && (var < high)) return true;
     eb0:	68 17       	cp	r22, r24
     eb2:	79 07       	cpc	r23, r25
     eb4:	10 f0       	brcs	.+4      	; 0xeba <between+0xa>
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	07 c0       	rjmp	.+14     	; 0xec8 <between+0x18>
     eba:	20 e0       	ldi	r18, 0x00	; 0
     ebc:	84 17       	cp	r24, r20
     ebe:	95 07       	cpc	r25, r21
     ec0:	08 f0       	brcs	.+2      	; 0xec4 <between+0x14>
     ec2:	21 e0       	ldi	r18, 0x01	; 1
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	28 27       	eor	r18, r24
	else return false;
}
     ec8:	82 2f       	mov	r24, r18
     eca:	08 95       	ret

00000ecc <pwm_pulse>:
	}
}

//Code to initiate an output pulse. Output pulses are only initiated if there is not a current pulse in progress
void pwm_pulse(void){
	if (STATE_Pwm != PWM_OUTPUT_PULSE){
     ecc:	80 91 00 20 	lds	r24, 0x2000
     ed0:	80 35       	cpi	r24, 0x50	; 80
     ed2:	31 f0       	breq	.+12     	; 0xee0 <pwm_pulse+0x14>
		STATE_Pwm = PWM_OUTPUT_PULSE; //Update state
     ed4:	80 e5       	ldi	r24, 0x50	; 80
     ed6:	80 93 00 20 	sts	0x2000, r24
		STATE_Pwm_Counter = PWM_PULSE_DURATION; //Load the counter
     eda:	84 e6       	ldi	r24, 0x64	; 100
     edc:	80 93 04 20 	sts	0x2004, r24
     ee0:	08 95       	ret

00000ee2 <service_pwm>:

//Mainline Loop PWM Service Routine -- use to manage output pulse
//...and trigger states
//---must run only once per 2ms looptime
void service_pwm(void){
	switch(STATE_Pwm){
     ee2:	80 91 00 20 	lds	r24, 0x2000
     ee6:	8f 34       	cpi	r24, 0x4F	; 79
     ee8:	89 f0       	breq	.+34     	; 0xf0c <service_pwm+0x2a>
     eea:	80 35       	cpi	r24, 0x50	; 80
     eec:	a1 f4       	brne	.+40     	; 0xf16 <service_pwm+0x34>
	case PWM_OUTPUT_HIGH:
		PORTA.OUTSET = B8(10000000); //PA7 output high
		break;
	case PWM_OUTPUT_PULSE:
		if (STATE_Pwm_Counter == 0)	{
     eee:	80 91 04 20 	lds	r24, 0x2004
     ef2:	88 23       	and	r24, r24
     ef4:	41 f4       	brne	.+16     	; 0xf06 <service_pwm+0x24>
			//Done with pulse!
			PORTA.OUTCLR = B8(10000000); //PA7 output low
     ef6:	80 e8       	ldi	r24, 0x80	; 128
     ef8:	e0 e0       	ldi	r30, 0x00	; 0
     efa:	f6 e0       	ldi	r31, 0x06	; 6
     efc:	86 83       	std	Z+6, r24	; 0x06
			STATE_Pwm = PWM_OUTPUT_LOW;	//Update State (Done with pulse)
     efe:	8e e4       	ldi	r24, 0x4E	; 78
     f00:	80 93 00 20 	sts	0x2000, r24
     f04:	08 95       	ret
		}
		else {
			STATE_Pwm_Counter--; //Decrement Counter
     f06:	81 50       	subi	r24, 0x01	; 1
     f08:	80 93 04 20 	sts	0x2004, r24
			PORTA.OUTSET = B8(10000000); //PA7 output high
     f0c:	80 e8       	ldi	r24, 0x80	; 128
     f0e:	e0 e0       	ldi	r30, 0x00	; 0
     f10:	f6 e0       	ldi	r31, 0x06	; 6
     f12:	85 83       	std	Z+5, r24	; 0x05
     f14:	08 95       	ret
		}
		break;
	case PWM_OUTPUT_LOW:
	default:
		PORTA.OUTCLR = B8(10000000); //PA7 output low
     f16:	80 e8       	ldi	r24, 0x80	; 128
     f18:	e0 e0       	ldi	r30, 0x00	; 0
     f1a:	f6 e0       	ldi	r31, 0x06	; 6
     f1c:	86 83       	std	Z+6, r24	; 0x06
     f1e:	08 95       	ret

00000f20 <pwm_decode>:
//Converts Pulse Width's into State Machine Changes
	//0x2000 = As.wav
	//0x4000 = Bs.wav
	//0x7000 = Cs.wav
	//0x9000 = Ds.wav
void pwm_decode(uint16_t width){
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	ec 01       	movw	r28, r24
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
}

boolean between(uint16_t var, uint16_t low, uint16_t high){
	if ((var > low) && (var < high)) return true;
     f26:	80 e1       	ldi	r24, 0x10	; 16
     f28:	c1 30       	cpi	r28, 0x01	; 1
     f2a:	d8 07       	cpc	r29, r24
     f2c:	08 f4       	brcc	.+2      	; 0xf30 <pwm_decode+0x10>
     f2e:	7b c0       	rjmp	.+246    	; 0x1026 <pwm_decode+0x106>
     f30:	80 e2       	ldi	r24, 0x20	; 32
     f32:	c0 30       	cpi	r28, 0x00	; 0
     f34:	d8 07       	cpc	r29, r24
     f36:	90 f4       	brcc	.+36     	; 0xf5c <pwm_decode+0x3c>
void pwm_decode(uint16_t width){
	static uint8_t last_code = 0;

	if (between(width,0x1000,0x2000) == true){
		//Found A code!
		STATE_Pwm = PWM_OUTPUT_HIGH; //A = Turn On Constantly
     f38:	8f e4       	ldi	r24, 0x4F	; 79
     f3a:	80 93 00 20 	sts	0x2000, r24
		last_code = 1; //Note that we've seen this code (A=1, B=2, etc)
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	80 93 05 20 	sts	0x2005, r24
		uart_enqueue(' ');
     f44:	80 e2       	ldi	r24, 0x20	; 32
     f46:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('<');
     f4a:	8c e3       	ldi	r24, 0x3C	; 60
     f4c:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('-');
     f50:	8d e2       	ldi	r24, 0x2D	; 45
     f52:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('A');
     f56:	81 e4       	ldi	r24, 0x41	; 65
     f58:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
}

boolean between(uint16_t var, uint16_t low, uint16_t high){
	if ((var > low) && (var < high)) return true;
     f5c:	80 e2       	ldi	r24, 0x20	; 32
     f5e:	c1 30       	cpi	r28, 0x01	; 1
     f60:	d8 07       	cpc	r29, r24
     f62:	08 f4       	brcc	.+2      	; 0xf66 <pwm_decode+0x46>
     f64:	60 c0       	rjmp	.+192    	; 0x1026 <pwm_decode+0x106>
     f66:	80 e3       	ldi	r24, 0x30	; 48
     f68:	c0 30       	cpi	r28, 0x00	; 0
     f6a:	d8 07       	cpc	r29, r24
     f6c:	90 f4       	brcc	.+36     	; 0xf92 <pwm_decode+0x72>
		uart_enqueue('-');
		uart_enqueue('A');
	}
	if (between(width,0x2000,0x3000) == true){
		//Found B code!
		STATE_Pwm = PWM_OUTPUT_LOW; //B = Turn Off Constantly
     f6e:	8e e4       	ldi	r24, 0x4E	; 78
     f70:	80 93 00 20 	sts	0x2000, r24
		last_code = 2; //Note that we've seen this code (A=1, B=2, etc)
     f74:	82 e0       	ldi	r24, 0x02	; 2
     f76:	80 93 05 20 	sts	0x2005, r24
		uart_enqueue(' ');
     f7a:	80 e2       	ldi	r24, 0x20	; 32
     f7c:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('<');
     f80:	8c e3       	ldi	r24, 0x3C	; 60
     f82:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('-');
     f86:	8d e2       	ldi	r24, 0x2D	; 45
     f88:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('B');
     f8c:	82 e4       	ldi	r24, 0x42	; 66
     f8e:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
}

boolean between(uint16_t var, uint16_t low, uint16_t high){
	if ((var > low) && (var < high)) return true;
     f92:	80 e4       	ldi	r24, 0x40	; 64
     f94:	c1 30       	cpi	r28, 0x01	; 1
     f96:	d8 07       	cpc	r29, r24
     f98:	08 f4       	brcc	.+2      	; 0xf9c <pwm_decode+0x7c>
     f9a:	45 c0       	rjmp	.+138    	; 0x1026 <pwm_decode+0x106>
     f9c:	80 e5       	ldi	r24, 0x50	; 80
     f9e:	c0 30       	cpi	r28, 0x00	; 0
     fa0:	d8 07       	cpc	r29, r24
     fa2:	e8 f4       	brcc	.+58     	; 0xfde <pwm_decode+0xbe>
		uart_enqueue('-');
		uart_enqueue('B');
	}
	if (between(width,0x4000,0x5000) == true){
		//Found C code!
		if (last_code != 3) pwm_pulse(); //C = Pulse for first C code encountered
     fa4:	80 91 05 20 	lds	r24, 0x2005
     fa8:	83 30       	cpi	r24, 0x03	; 3
     faa:	51 f0       	breq	.+20     	; 0xfc0 <pwm_decode+0xa0>
	}
}

//Code to initiate an output pulse. Output pulses are only initiated if there is not a current pulse in progress
void pwm_pulse(void){
	if (STATE_Pwm != PWM_OUTPUT_PULSE){
     fac:	80 91 00 20 	lds	r24, 0x2000
     fb0:	80 35       	cpi	r24, 0x50	; 80
     fb2:	31 f0       	breq	.+12     	; 0xfc0 <pwm_decode+0xa0>
		STATE_Pwm = PWM_OUTPUT_PULSE; //Update state
     fb4:	80 e5       	ldi	r24, 0x50	; 80
     fb6:	80 93 00 20 	sts	0x2000, r24
		STATE_Pwm_Counter = PWM_PULSE_DURATION; //Load the counter
     fba:	84 e6       	ldi	r24, 0x64	; 100
     fbc:	80 93 04 20 	sts	0x2004, r24
		uart_enqueue('B');
	}
	if (between(width,0x4000,0x5000) == true){
		//Found C code!
		if (last_code != 3) pwm_pulse(); //C = Pulse for first C code encountered
		last_code = 3; //Note that we've seen this code (A=1, B=2, etc)
     fc0:	83 e0       	ldi	r24, 0x03	; 3
     fc2:	80 93 05 20 	sts	0x2005, r24
		uart_enqueue(' ');
     fc6:	80 e2       	ldi	r24, 0x20	; 32
     fc8:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('<');
     fcc:	8c e3       	ldi	r24, 0x3C	; 60
     fce:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('-');
     fd2:	8d e2       	ldi	r24, 0x2D	; 45
     fd4:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('C');
     fd8:	83 e4       	ldi	r24, 0x43	; 67
     fda:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
}

boolean between(uint16_t var, uint16_t low, uint16_t high){
	if ((var > low) && (var < high)) return true;
     fde:	80 e7       	ldi	r24, 0x70	; 112
     fe0:	c1 30       	cpi	r28, 0x01	; 1
     fe2:	d8 07       	cpc	r29, r24
     fe4:	00 f1       	brcs	.+64     	; 0x1026 <pwm_decode+0x106>
     fe6:	c0 50       	subi	r28, 0x00	; 0
     fe8:	d0 48       	sbci	r29, 0x80	; 128
     fea:	e8 f4       	brcc	.+58     	; 0x1026 <pwm_decode+0x106>
		uart_enqueue('-');
		uart_enqueue('C');
	}
	if (between(width,0x7000,0x8000) == true){
		//Found D code!
		if (last_code != 4) pwm_pulse(); //D = Pulse for first D code encountered
     fec:	80 91 05 20 	lds	r24, 0x2005
     ff0:	84 30       	cpi	r24, 0x04	; 4
     ff2:	51 f0       	breq	.+20     	; 0x1008 <pwm_decode+0xe8>
	}
}

//Code to initiate an output pulse. Output pulses are only initiated if there is not a current pulse in progress
void pwm_pulse(void){
	if (STATE_Pwm != PWM_OUTPUT_PULSE){
     ff4:	80 91 00 20 	lds	r24, 0x2000
     ff8:	80 35       	cpi	r24, 0x50	; 80
     ffa:	31 f0       	breq	.+12     	; 0x1008 <pwm_decode+0xe8>
		STATE_Pwm = PWM_OUTPUT_PULSE; //Update state
     ffc:	80 e5       	ldi	r24, 0x50	; 80
     ffe:	80 93 00 20 	sts	0x2000, r24
		STATE_Pwm_Counter = PWM_PULSE_DURATION; //Load the counter
    1002:	84 e6       	ldi	r24, 0x64	; 100
    1004:	80 93 04 20 	sts	0x2004, r24
		uart_enqueue('C');
	}
	if (between(width,0x7000,0x8000) == true){
		//Found D code!
		if (last_code != 4) pwm_pulse(); //D = Pulse for first D code encountered
		last_code = 4; //Note that we've seen this code (A=1, B=2, etc)
    1008:	84 e0       	ldi	r24, 0x04	; 4
    100a:	80 93 05 20 	sts	0x2005, r24
		uart_enqueue(' ');
    100e:	80 e2       	ldi	r24, 0x20	; 32
    1010:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('<');
    1014:	8c e3       	ldi	r24, 0x3C	; 60
    1016:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('-');
    101a:	8d e2       	ldi	r24, 0x2D	; 45
    101c:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
		uart_enqueue('D');
    1020:	84 e4       	ldi	r24, 0x44	; 68
    1022:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
	}
}
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	08 95       	ret

0000102c <__vector_68>:
boolean pwm_mode(){
	return sw_on(SW1);
}

//ANALOG COMPARATOR (AC0) OUTPUT TOGGLE INTERRUPT
SIGNAL(ACA_AC0_vect){
    102c:	1f 92       	push	r1
    102e:	0f 92       	push	r0
    1030:	0f b6       	in	r0, 0x3f	; 63
    1032:	0f 92       	push	r0
    1034:	11 24       	eor	r1, r1
    1036:	2f 93       	push	r18
    1038:	3f 93       	push	r19
    103a:	4f 93       	push	r20
    103c:	5f 93       	push	r21
    103e:	6f 93       	push	r22
    1040:	7f 93       	push	r23
    1042:	8f 93       	push	r24
    1044:	9f 93       	push	r25
    1046:	af 93       	push	r26
    1048:	bf 93       	push	r27
    104a:	cf 93       	push	r28
    104c:	df 93       	push	r29
    104e:	ef 93       	push	r30
    1050:	ff 93       	push	r31
	uint16_t width;
	led_toggle(LED_MID);
    1052:	81 e0       	ldi	r24, 0x01	; 1
    1054:	0e 94 8f 05 	call	0xb1e	; 0xb1e <led_toggle>
	if ((ACA.STATUS & B8(00010000)) > 0){
    1058:	80 91 87 03 	lds	r24, 0x0387
    105c:	84 ff       	sbrs	r24, 4
    105e:	07 c0       	rjmp	.+14     	; 0x106e <__vector_68+0x42>
//#############################################################
//## TIMER CAPTURE FUNCTIONS
//#############################################################
void pwm_timer_reset(void){
	//Reset the timer effective immediately!
	TCE0.CNTL = 0x00;
    1060:	e0 e0       	ldi	r30, 0x00	; 0
    1062:	fa e0       	ldi	r31, 0x0A	; 10
    1064:	10 a2       	std	Z+32, r1	; 0x20
	TCE0.CNTH = 0x00;	
    1066:	11 a2       	std	Z+33, r1	; 0x21
	//Clear the overflow flag (actually, clears all flags, but OVIF is the only one we use)
	TCE0.INTFLAGS = 0xFF; 
    1068:	8f ef       	ldi	r24, 0xFF	; 255
    106a:	84 87       	std	Z+12, r24	; 0x0c
    106c:	14 c0       	rjmp	.+40     	; 0x1096 <__vector_68+0x6a>
		//Detected: RISING edge
		pwm_timer_reset();
	}
	else {
		//Detected: FALLING edge
		width = TCE0.CNT;
    106e:	c0 91 20 0a 	lds	r28, 0x0A20
    1072:	d0 91 21 0a 	lds	r29, 0x0A21
		if ((TCE0.INTFLAGS & _BV(0)) == 0x00){
    1076:	80 91 0c 0a 	lds	r24, 0x0A0C
    107a:	80 fd       	sbrc	r24, 0
    107c:	0c c0       	rjmp	.+24     	; 0x1096 <__vector_68+0x6a>
			uart_enqueue(13);
    107e:	8d e0       	ldi	r24, 0x0D	; 13
    1080:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
			uart_enqueue(10);
    1084:	8a e0       	ldi	r24, 0x0A	; 10
    1086:	0e 94 34 09 	call	0x1268	; 0x1268 <uart_enqueue>
			uart_enq_HEX16(width);
    108a:	ce 01       	movw	r24, r28
    108c:	0e 94 a3 04 	call	0x946	; 0x946 <uart_enq_HEX16>
			pwm_decode(width);
    1090:	ce 01       	movw	r24, r28
    1092:	0e 94 90 07 	call	0xf20	; 0xf20 <pwm_decode>
		}
	}
}
    1096:	ff 91       	pop	r31
    1098:	ef 91       	pop	r30
    109a:	df 91       	pop	r29
    109c:	cf 91       	pop	r28
    109e:	bf 91       	pop	r27
    10a0:	af 91       	pop	r26
    10a2:	9f 91       	pop	r25
    10a4:	8f 91       	pop	r24
    10a6:	7f 91       	pop	r23
    10a8:	6f 91       	pop	r22
    10aa:	5f 91       	pop	r21
    10ac:	4f 91       	pop	r20
    10ae:	3f 91       	pop	r19
    10b0:	2f 91       	pop	r18
    10b2:	0f 90       	pop	r0
    10b4:	0f be       	out	0x3f, r0	; 63
    10b6:	0f 90       	pop	r0
    10b8:	1f 90       	pop	r1
    10ba:	18 95       	reti

000010bc <pwm_mode>:
		init_ac();
}

//Returns 'true' if the user configuration switch is set to Audio/PWM mode
boolean pwm_mode(){
	return sw_on(SW1);
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	0e 94 c3 05 	call	0xb86	; 0xb86 <sw_on>
}
    10c2:	08 95       	ret

000010c4 <pwm_disable>:
		STATE_Autolevel = AUTOLEVEL_IDLE;
}

void pwm_disable(){
	//TIMER (PORTD.TC0)
		TCE0.CTRLA = 0x00; //Disable Timer
    10c4:	10 92 00 0a 	sts	0x0A00, r1

	//DIGITAL-TO-ANALOG CONVERTER (DAC)
		//PORTB.DAC0 -- Vbackground; Enable to allow DAC operation
		dac_output0(ENABLE); //Overrides PB2 GPIO function
    10c8:	8a e2       	ldi	r24, 0x2A	; 42
    10ca:	0e 94 25 06 	call	0xc4a	; 0xc4a <dac_output0>

	//ANALOG COMPARATOR
		init_ac();
    10ce:	0e 94 3c 06 	call	0xc78	; 0xc78 <init_ac>
}
    10d2:	08 95       	ret

000010d4 <pwm_enable>:
//Initialize the PWM module
void init_pwm(){
	//no init needed. We initialize when the mode is activated.
}

void pwm_enable(){
    10d4:	0f 93       	push	r16
    10d6:	1f 93       	push	r17
	//TIMER (PORTD.TC0)
		TCE0.CTRLA = B8(00000101); //Timer Clock source is 32MHz/64; ~130ms Range @ 2uS resolution
    10d8:	e0 e0       	ldi	r30, 0x00	; 0
    10da:	fa e0       	ldi	r31, 0x0A	; 10
    10dc:	85 e0       	ldi	r24, 0x05	; 5
    10de:	80 83       	st	Z, r24
		TCE0.CTRLB = 0x00; //Turn off output pins (for both input capture and waveform generation)
    10e0:	11 82       	std	Z+1, r1	; 0x01
		TCE0.CTRLC = 0x00; //Only for the compare output unit
    10e2:	12 82       	std	Z+2, r1	; 0x02
		TCE0.CTRLD = B8(00000000); //Disable Event Unit
    10e4:	13 82       	std	Z+3, r1	; 0x03
		TCE0.CTRLE = 0x00; //Leave the counter in 16 (rather than 8) bit mode
    10e6:	14 82       	std	Z+4, r1	; 0x04

	//DIGITAL-TO-ANALOG CONVERTER (DAC)
		//PORTB.DAC0 -- Vbackground; disable so GPIO can take over and set to ground (prevents us from having to disturb the current DAC output value so we can easily restore it later if need be)
		dac_output0(DISABLE);
    10e8:	89 e2       	ldi	r24, 0x29	; 41
    10ea:	0e 94 25 06 	call	0xc4a	; 0xc4a <dac_output0>
		//Output Low on PB2
		PORTB.OUTCLR = B8(00000100);
    10ee:	e0 e2       	ldi	r30, 0x20	; 32
    10f0:	f6 e0       	ldi	r31, 0x06	; 6
    10f2:	84 e0       	ldi	r24, 0x04	; 4
    10f4:	86 83       	std	Z+6, r24	; 0x06
		PORTB.DIRSET = B8(00000100);
    10f6:	81 83       	std	Z+1, r24	; 0x01

	//ANALOG COMPARATOR
		ACA.AC0MUXCTRL = B8(00000111); //Pos. input = PA0; Neg. Input = VCC Scaler; 
    10f8:	00 e8       	ldi	r16, 0x80	; 128
    10fa:	13 e0       	ldi	r17, 0x03	; 3
    10fc:	87 e0       	ldi	r24, 0x07	; 7
    10fe:	f8 01       	movw	r30, r16
    1100:	82 83       	std	Z+2, r24	; 0x02
		ACA.CTRLB = 20; //VCC Scaler = VCC/2 = 2.5V
    1102:	84 e1       	ldi	r24, 0x14	; 20
    1104:	85 83       	std	Z+5, r24	; 0x05
		ac_output(DISABLE); //Turn off PA7 output pin (we'll use it directly to control the external peripheral)
    1106:	89 e2       	ldi	r24, 0x29	; 41
    1108:	0e 94 45 06 	call	0xc8a	; 0xc8a <ac_output>
		ACA.AC0CTRL = B8(00111101); //enable AC0; 50mV hysterysis; high priority interrupt on edge toggle; high-speed mode
    110c:	8d e3       	ldi	r24, 0x3D	; 61
    110e:	f8 01       	movw	r30, r16
    1110:	80 83       	st	Z, r24
		PORTA.OUTCLR = B8(10000000); //PA7 output low
    1112:	e0 e0       	ldi	r30, 0x00	; 0
    1114:	f6 e0       	ldi	r31, 0x06	; 6
    1116:	80 e8       	ldi	r24, 0x80	; 128
    1118:	86 83       	std	Z+6, r24	; 0x06
		PORTA.DIRSET = B8(10000000); //Set PA7 as output (should be anyway)
    111a:	81 83       	std	Z+1, r24	; 0x01

	//BUTTON
		STATE_Autolevel = AUTOLEVEL_IDLE;
    111c:	10 92 02 20 	sts	0x2002, r1
}
    1120:	1f 91       	pop	r17
    1122:	0f 91       	pop	r16
    1124:	08 95       	ret

00001126 <uart_transmit>:
//Starts a transmission out of the UART if the UART is ready to receive data
//and we have data to send. (helper function to the ISR so that we can initiate 
//the first transfer
void inline uart_transmit(){
	//keep loading until data register is full or outgoing queue is empty
	while (((port->STATUS & _BV(5)) == B8(00100000)) && (uart_count() > 0)){
    1126:	a0 91 16 21 	lds	r26, 0x2116
    112a:	b0 91 17 21 	lds	r27, 0x2117
    112e:	12 c0       	rjmp	.+36     	; 0x1154 <uart_transmit+0x2e>
#endif
}

inline uint8_t uart_dequeue(void){
	uint8_t oldtail;
	oldtail = uart_tail;
    1130:	e0 91 15 21 	lds	r30, 0x2115
	uart_tail++;
    1134:	80 91 15 21 	lds	r24, 0x2115
    1138:	8f 5f       	subi	r24, 0xFF	; 255
    113a:	80 93 15 21 	sts	0x2115, r24
	if (uart_tail >= MAX_BUFFER_LEN){
    113e:	80 91 15 21 	lds	r24, 0x2115
    1142:	8a 3f       	cpi	r24, 0xFA	; 250
    1144:	10 f0       	brcs	.+4      	; 0x114a <uart_transmit+0x24>
		uart_tail = 0;
    1146:	10 92 15 21 	sts	0x2115, r1
	}
	return uart_buffer[oldtail];
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	e6 5e       	subi	r30, 0xE6	; 230
    114e:	ff 4d       	sbci	r31, 0xDF	; 223
    1150:	80 81       	ld	r24, Z
//and we have data to send. (helper function to the ISR so that we can initiate 
//the first transfer
void inline uart_transmit(){
	//keep loading until data register is full or outgoing queue is empty
	while (((port->STATUS & _BV(5)) == B8(00100000)) && (uart_count() > 0)){
		port->DATA = uart_dequeue();
    1152:	8c 93       	st	X, r24
//Starts a transmission out of the UART if the UART is ready to receive data
//and we have data to send. (helper function to the ISR so that we can initiate 
//the first transfer
void inline uart_transmit(){
	//keep loading until data register is full or outgoing queue is empty
	while (((port->STATUS & _BV(5)) == B8(00100000)) && (uart_count() > 0)){
    1154:	11 96       	adiw	r26, 0x01	; 1
    1156:	8c 91       	ld	r24, X
    1158:	11 97       	sbiw	r26, 0x01	; 1
    115a:	85 ff       	sbrs	r24, 5
    115c:	12 c0       	rjmp	.+36     	; 0x1182 <uart_transmit+0x5c>
	uart_head = 0;
	uart_tail = 0;
}

inline uint8_t uart_count(void){
	if (uart_head >= uart_tail){	
    115e:	90 91 19 20 	lds	r25, 0x2019
    1162:	80 91 15 21 	lds	r24, 0x2115
    1166:	98 17       	cp	r25, r24
    1168:	28 f0       	brcs	.+10     	; 0x1174 <uart_transmit+0x4e>
		return (uart_head - uart_tail);
    116a:	90 91 19 20 	lds	r25, 0x2019
    116e:	80 91 15 21 	lds	r24, 0x2115
    1172:	05 c0       	rjmp	.+10     	; 0x117e <uart_transmit+0x58>
	}
	else {
		return ((MAX_BUFFER_LEN-uart_tail)+uart_head);
    1174:	90 91 19 20 	lds	r25, 0x2019
    1178:	80 91 15 21 	lds	r24, 0x2115
    117c:	96 50       	subi	r25, 0x06	; 6
    117e:	98 1b       	sub	r25, r24
//Starts a transmission out of the UART if the UART is ready to receive data
//and we have data to send. (helper function to the ISR so that we can initiate 
//the first transfer
void inline uart_transmit(){
	//keep loading until data register is full or outgoing queue is empty
	while (((port->STATUS & _BV(5)) == B8(00100000)) && (uart_count() > 0)){
    1180:	b9 f6       	brne	.-82     	; 0x1130 <uart_transmit+0xa>
	uart_head = 0;
	uart_tail = 0;
}

inline uint8_t uart_count(void){
	if (uart_head >= uart_tail){	
    1182:	90 91 19 20 	lds	r25, 0x2019
    1186:	80 91 15 21 	lds	r24, 0x2115
    118a:	98 17       	cp	r25, r24
    118c:	28 f0       	brcs	.+10     	; 0x1198 <uart_transmit+0x72>
		return (uart_head - uart_tail);
    118e:	90 91 19 20 	lds	r25, 0x2019
    1192:	80 91 15 21 	lds	r24, 0x2115
    1196:	05 c0       	rjmp	.+10     	; 0x11a2 <uart_transmit+0x7c>
	}
	else {
		return ((MAX_BUFFER_LEN-uart_tail)+uart_head);
    1198:	90 91 19 20 	lds	r25, 0x2019
    119c:	80 91 15 21 	lds	r24, 0x2115
    11a0:	96 50       	subi	r25, 0x06	; 6
    11a2:	98 1b       	sub	r25, r24
	while (((port->STATUS & _BV(5)) == B8(00100000)) && (uart_count() > 0)){
		port->DATA = uart_dequeue();
	}

	//else: wait for the next tx complete to empty out the data register
	if(uart_count()>0) uart_txbuffer_enable();
    11a4:	29 f0       	breq	.+10     	; 0x11b0 <uart_transmit+0x8a>
		init_uart_obuffer();
		//init_uart_ibuffer(); //not implemented yet!
}

void uart_txbuffer_enable(){
	port->CTRLA = (port->CTRLA | B8(00000010));	//Set the Data Register Empty Interrupt to Medium Priority (timer needs to be higher!)
    11a6:	13 96       	adiw	r26, 0x03	; 3
    11a8:	8c 91       	ld	r24, X
    11aa:	13 97       	sbiw	r26, 0x03	; 3
    11ac:	82 60       	ori	r24, 0x02	; 2
    11ae:	04 c0       	rjmp	.+8      	; 0x11b8 <uart_transmit+0x92>
}

void uart_txbuffer_disable(){
	port->CTRLA = (port->CTRLA & B8(11111100));	//Disable the Data Register Empty Interrupt
    11b0:	13 96       	adiw	r26, 0x03	; 3
    11b2:	8c 91       	ld	r24, X
    11b4:	13 97       	sbiw	r26, 0x03	; 3
    11b6:	8c 7f       	andi	r24, 0xFC	; 252
    11b8:	13 96       	adiw	r26, 0x03	; 3
    11ba:	8c 93       	st	X, r24
    11bc:	08 95       	ret

000011be <__vector_59>:
//** [PORT SPECIFIC CODE]
//************************************************************************
//************************************************************************

//DATA TRANSMIT COMPLETE
SIGNAL(USARTE0_DRE_vect){
    11be:	1f 92       	push	r1
    11c0:	0f 92       	push	r0
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	0f 92       	push	r0
    11c6:	11 24       	eor	r1, r1
    11c8:	2f 93       	push	r18
    11ca:	3f 93       	push	r19
    11cc:	4f 93       	push	r20
    11ce:	5f 93       	push	r21
    11d0:	6f 93       	push	r22
    11d2:	7f 93       	push	r23
    11d4:	8f 93       	push	r24
    11d6:	9f 93       	push	r25
    11d8:	af 93       	push	r26
    11da:	bf 93       	push	r27
    11dc:	ef 93       	push	r30
    11de:	ff 93       	push	r31
	uart_transmit();	
    11e0:	0e 94 93 08 	call	0x1126	; 0x1126 <uart_transmit>
}
    11e4:	ff 91       	pop	r31
    11e6:	ef 91       	pop	r30
    11e8:	bf 91       	pop	r27
    11ea:	af 91       	pop	r26
    11ec:	9f 91       	pop	r25
    11ee:	8f 91       	pop	r24
    11f0:	7f 91       	pop	r23
    11f2:	6f 91       	pop	r22
    11f4:	5f 91       	pop	r21
    11f6:	4f 91       	pop	r20
    11f8:	3f 91       	pop	r19
    11fa:	2f 91       	pop	r18
    11fc:	0f 90       	pop	r0
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	0f 90       	pop	r0
    1202:	1f 90       	pop	r1
    1204:	18 95       	reti

00001206 <init_uart_buffer>:
	else uart_txbuffer_disable();
}

void init_uart_buffer(USART_t* which){
	//Setup UART hardware
		port = which;
    1206:	80 93 16 21 	sts	0x2116, r24
    120a:	90 93 17 21 	sts	0x2117, r25
/** Insert from head. Read from tail. The goal is to be fast (very fast) and light.
	No protection is provided for buffer overflow! Be careful! */
//***************************************************

void init_uart_obuffer(void){
	uart_head = 0;
    120e:	10 92 19 20 	sts	0x2019, r1
	uart_tail = 0;
    1212:	10 92 15 21 	sts	0x2115, r1
		port = which;

	//Setup data buffers
		init_uart_obuffer();
		//init_uart_ibuffer(); //not implemented yet!
}
    1216:	08 95       	ret

00001218 <uart_txbuffer_enable>:

void uart_txbuffer_enable(){
	port->CTRLA = (port->CTRLA | B8(00000010));	//Set the Data Register Empty Interrupt to Medium Priority (timer needs to be higher!)
    1218:	e0 91 16 21 	lds	r30, 0x2116
    121c:	f0 91 17 21 	lds	r31, 0x2117
    1220:	83 81       	ldd	r24, Z+3	; 0x03
    1222:	82 60       	ori	r24, 0x02	; 2
    1224:	83 83       	std	Z+3, r24	; 0x03
}
    1226:	08 95       	ret

00001228 <uart_txbuffer_disable>:

void uart_txbuffer_disable(){
	port->CTRLA = (port->CTRLA & B8(11111100));	//Disable the Data Register Empty Interrupt
    1228:	e0 91 16 21 	lds	r30, 0x2116
    122c:	f0 91 17 21 	lds	r31, 0x2117
    1230:	83 81       	ldd	r24, Z+3	; 0x03
    1232:	8c 7f       	andi	r24, 0xFC	; 252
    1234:	83 83       	std	Z+3, r24	; 0x03
}
    1236:	08 95       	ret

00001238 <init_uart_obuffer>:
/** Insert from head. Read from tail. The goal is to be fast (very fast) and light.
	No protection is provided for buffer overflow! Be careful! */
//***************************************************

void init_uart_obuffer(void){
	uart_head = 0;
    1238:	10 92 19 20 	sts	0x2019, r1
	uart_tail = 0;
    123c:	10 92 15 21 	sts	0x2115, r1
}
    1240:	08 95       	ret

00001242 <uart_count>:

inline uint8_t uart_count(void){
	if (uart_head >= uart_tail){	
    1242:	90 91 19 20 	lds	r25, 0x2019
    1246:	80 91 15 21 	lds	r24, 0x2115
    124a:	98 17       	cp	r25, r24
    124c:	28 f0       	brcs	.+10     	; 0x1258 <uart_count+0x16>
		return (uart_head - uart_tail);
    124e:	90 91 19 20 	lds	r25, 0x2019
    1252:	80 91 15 21 	lds	r24, 0x2115
    1256:	05 c0       	rjmp	.+10     	; 0x1262 <uart_count+0x20>
	}
	else {
		return ((MAX_BUFFER_LEN-uart_tail)+uart_head);
    1258:	90 91 19 20 	lds	r25, 0x2019
    125c:	80 91 15 21 	lds	r24, 0x2115
    1260:	96 50       	subi	r25, 0x06	; 6
    1262:	98 1b       	sub	r25, r24
	}
}
    1264:	89 2f       	mov	r24, r25
    1266:	08 95       	ret

00001268 <uart_enqueue>:
/**This is the queue used to send data back to the command and control GUI. The #define UART_DEBUG can be used to disable normal serial activity through this queue
	The blue LED is used in this routine to signal buffer overflow, which, due to the real-time scheduled nature of the EEICM firmware architecture, should not happen.
	This function is inactive when in UART DEBUG mode. Calls to this function have no effect during this period.*/
inline void uart_enqueue(uint8_t datain){
#ifndef UART_DEBUG
	uart_buffer[uart_head] = datain;
    1268:	e0 91 19 20 	lds	r30, 0x2019
    126c:	f0 e0       	ldi	r31, 0x00	; 0
    126e:	e6 5e       	subi	r30, 0xE6	; 230
    1270:	ff 4d       	sbci	r31, 0xDF	; 223
    1272:	80 83       	st	Z, r24
	uart_head++;
    1274:	80 91 19 20 	lds	r24, 0x2019
    1278:	8f 5f       	subi	r24, 0xFF	; 255
    127a:	80 93 19 20 	sts	0x2019, r24
	if (uart_head >= MAX_BUFFER_LEN){
    127e:	80 91 19 20 	lds	r24, 0x2019
    1282:	8a 3f       	cpi	r24, 0xFA	; 250
    1284:	10 f0       	brcs	.+4      	; 0x128a <uart_enqueue+0x22>
		uart_head = 0;
    1286:	10 92 19 20 	sts	0x2019, r1
	}
	uart_transmit(); //start the transmission process.
    128a:	0e 94 93 08 	call	0x1126	; 0x1126 <uart_transmit>
#endif
}
    128e:	08 95       	ret

00001290 <uart_dequeue>:

inline uint8_t uart_dequeue(void){
	uint8_t oldtail;
	oldtail = uart_tail;
    1290:	e0 91 15 21 	lds	r30, 0x2115
	uart_tail++;
    1294:	80 91 15 21 	lds	r24, 0x2115
    1298:	8f 5f       	subi	r24, 0xFF	; 255
    129a:	80 93 15 21 	sts	0x2115, r24
	if (uart_tail >= MAX_BUFFER_LEN){
    129e:	80 91 15 21 	lds	r24, 0x2115
    12a2:	8a 3f       	cpi	r24, 0xFA	; 250
    12a4:	10 f0       	brcs	.+4      	; 0x12aa <uart_dequeue+0x1a>
		uart_tail = 0;
    12a6:	10 92 15 21 	sts	0x2115, r1
	}
	return uart_buffer[oldtail];
    12aa:	f0 e0       	ldi	r31, 0x00	; 0
    12ac:	e6 5e       	subi	r30, 0xE6	; 230
    12ae:	ff 4d       	sbci	r31, 0xDF	; 223
    12b0:	80 81       	ld	r24, Z
}
    12b2:	08 95       	ret

000012b4 <init_uart_ibuffer>:
/** Insert from head. Read from tail. The goal is to be fast (very fast) and light.
	No protection is provided for buffer overflow! Be careful! */
//***************************************************

void init_uart_ibuffer(void){
	uart_ihead = 0;
    12b4:	10 92 14 21 	sts	0x2114, r1
	uart_itail = 0;
    12b8:	10 92 0e 20 	sts	0x200E, r1
}
    12bc:	08 95       	ret

000012be <uart_icount>:

inline uint8_t uart_icount(void){
	if (uart_ihead >= uart_itail){	
    12be:	90 91 14 21 	lds	r25, 0x2114
    12c2:	80 91 0e 20 	lds	r24, 0x200E
    12c6:	98 17       	cp	r25, r24
    12c8:	28 f0       	brcs	.+10     	; 0x12d4 <uart_icount+0x16>
		return (uart_ihead - uart_itail);
    12ca:	90 91 14 21 	lds	r25, 0x2114
    12ce:	80 91 0e 20 	lds	r24, 0x200E
    12d2:	05 c0       	rjmp	.+10     	; 0x12de <uart_icount+0x20>
	}
	else {
		return ((MAX_IBUFFER_LEN-uart_itail)+uart_ihead);
    12d4:	90 91 14 21 	lds	r25, 0x2114
    12d8:	80 91 0e 20 	lds	r24, 0x200E
    12dc:	96 5f       	subi	r25, 0xF6	; 246
    12de:	98 1b       	sub	r25, r24
	}
}
    12e0:	89 2f       	mov	r24, r25
    12e2:	08 95       	ret

000012e4 <uart_ienqueue>:

inline void uart_ienqueue(uint8_t datain){
	uart_ibuffer[uart_ihead] = datain;
    12e4:	e0 91 14 21 	lds	r30, 0x2114
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	e1 5f       	subi	r30, 0xF1	; 241
    12ec:	ff 4d       	sbci	r31, 0xDF	; 223
    12ee:	80 83       	st	Z, r24
	uart_ihead++;
    12f0:	80 91 14 21 	lds	r24, 0x2114
    12f4:	8f 5f       	subi	r24, 0xFF	; 255
    12f6:	80 93 14 21 	sts	0x2114, r24
	if (uart_ihead >= MAX_IBUFFER_LEN){
    12fa:	80 91 14 21 	lds	r24, 0x2114
    12fe:	8a 30       	cpi	r24, 0x0A	; 10
    1300:	10 f0       	brcs	.+4      	; 0x1306 <uart_ienqueue+0x22>
		uart_ihead = 0;
    1302:	10 92 14 21 	sts	0x2114, r1
    1306:	08 95       	ret

00001308 <uart_idequeue>:
	}
}

inline uint8_t uart_idequeue(void){
	uint8_t oldtail;
	oldtail = uart_itail;
    1308:	e0 91 0e 20 	lds	r30, 0x200E
	uart_itail++;
    130c:	80 91 0e 20 	lds	r24, 0x200E
    1310:	8f 5f       	subi	r24, 0xFF	; 255
    1312:	80 93 0e 20 	sts	0x200E, r24
	if (uart_itail >= MAX_IBUFFER_LEN){
    1316:	80 91 0e 20 	lds	r24, 0x200E
    131a:	8a 30       	cpi	r24, 0x0A	; 10
    131c:	10 f0       	brcs	.+4      	; 0x1322 <uart_idequeue+0x1a>
		uart_itail = 0;
    131e:	10 92 0e 20 	sts	0x200E, r1
	}
	return uart_ibuffer[oldtail];
    1322:	f0 e0       	ldi	r31, 0x00	; 0
    1324:	e1 5f       	subi	r30, 0xF1	; 241
    1326:	ff 4d       	sbci	r31, 0xDF	; 223
    1328:	80 81       	ld	r24, Z
}
    132a:	08 95       	ret

0000132c <__udivmodsi4>:
    132c:	a1 e2       	ldi	r26, 0x21	; 33
    132e:	1a 2e       	mov	r1, r26
    1330:	aa 1b       	sub	r26, r26
    1332:	bb 1b       	sub	r27, r27
    1334:	fd 01       	movw	r30, r26
    1336:	0d c0       	rjmp	.+26     	; 0x1352 <__udivmodsi4_ep>

00001338 <__udivmodsi4_loop>:
    1338:	aa 1f       	adc	r26, r26
    133a:	bb 1f       	adc	r27, r27
    133c:	ee 1f       	adc	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	a2 17       	cp	r26, r18
    1342:	b3 07       	cpc	r27, r19
    1344:	e4 07       	cpc	r30, r20
    1346:	f5 07       	cpc	r31, r21
    1348:	20 f0       	brcs	.+8      	; 0x1352 <__udivmodsi4_ep>
    134a:	a2 1b       	sub	r26, r18
    134c:	b3 0b       	sbc	r27, r19
    134e:	e4 0b       	sbc	r30, r20
    1350:	f5 0b       	sbc	r31, r21

00001352 <__udivmodsi4_ep>:
    1352:	66 1f       	adc	r22, r22
    1354:	77 1f       	adc	r23, r23
    1356:	88 1f       	adc	r24, r24
    1358:	99 1f       	adc	r25, r25
    135a:	1a 94       	dec	r1
    135c:	69 f7       	brne	.-38     	; 0x1338 <__udivmodsi4_loop>
    135e:	60 95       	com	r22
    1360:	70 95       	com	r23
    1362:	80 95       	com	r24
    1364:	90 95       	com	r25
    1366:	9b 01       	movw	r18, r22
    1368:	ac 01       	movw	r20, r24
    136a:	bd 01       	movw	r22, r26
    136c:	cf 01       	movw	r24, r30
    136e:	08 95       	ret

00001370 <_exit>:
    1370:	f8 94       	cli

00001372 <__stop_program>:
    1372:	ff cf       	rjmp	.-2      	; 0x1372 <__stop_program>
